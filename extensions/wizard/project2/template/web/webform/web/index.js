/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/App.css":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/App.css ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \"body{\\r\\n    margin: 20px 10px 10px 50px;\\r\\n}\\r\\n\\r\\nbutton {\\r\\n    display: inline-block;\\r\\n    outline: none;\\r\\n    cursor: pointer;\\r\\n    text-align: center;\\r\\n    text-decoration: none;\\r\\n    font: 11pt/100% Arial, Helvetica, sans-serif;\\r\\n    padding: 5pt 8pt;\\r\\n    text-shadow: 0 1pt 1pt rgba(0, 0, 0, .3);\\r\\n    -webkit-border-radius: 5px;\\r\\n    -moz-border-radius:4pt;\\r\\n    border-radius: 4pt;  \\r\\n    box-shadow: 0 1ptt 2ptpt rgba(0, 0, 0, .2);\\r\\n    color: #d9eef7;\\r\\n    border: solid 1px #0076a3;\\r\\n    background: #0095cd; \\r\\n    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00adee', endColorstr='#00678e');\\r\\n}\\r\\n\\r\\nbutton:hover {\\r\\n    background: #007ead; \\r\\n    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00678e', endColorstr='#0095cc');\\r\\n}\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./src/App.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/nervjs/dist/index.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/nervjs/dist/index.esm.js ***!
  \***********************************************/
/*! exports provided: Children, Component, PureComponent, createElement, cloneElement, render, nextTick, options, findDOMNode, isValidElement, unmountComponentAtNode, createPortal, unstable_renderSubtreeIntoContainer, hydrate, createFactory, unstable_batchedUpdates, version, PropTypes, createRef, forwardRef, memo, createContext, renderComponent, getHooks, Current, Fragment, useEffect, useLayoutEffect, useReducer, useState, useRef, useCallback, useMemo, useImperativeHandle, useContext, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Children\", function() { return Children; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PureComponent\", function() { return PureComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return createElement$2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneElement\", function() { return cloneElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nextTick\", function() { return nextTick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDOMNode\", function() { return findDOMNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidElement\", function() { return isValidElement$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unmountComponentAtNode\", function() { return unmountComponentAtNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unstable_renderSubtreeIntoContainer\", function() { return unstable_renderSubtreeIntoContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return hydrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFactory\", function() { return createFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unstable_batchedUpdates\", function() { return unstable_batchedUpdates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropTypes\", function() { return PropTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return createRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardRef\", function() { return forwardRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memo\", function() { return memo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createContext\", function() { return createContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderComponent\", function() { return renderComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHooks\", function() { return getHooks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Current\", function() { return Current; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Fragment\", function() { return Fragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEffect\", function() { return useEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useLayoutEffect\", function() { return useLayoutEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useReducer\", function() { return useReducer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useState\", function() { return useState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useRef\", function() { return useRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCallback\", function() { return useCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useMemo\", function() { return useMemo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useImperativeHandle\", function() { return useImperativeHandle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useContext\", function() { return useContext; });\n// tslint:disable-next-line\nvar global = function () {\n  var local;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      // tslint:disable-next-line:function-constructor\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('global object is unavailable in this environment');\n    }\n  }\n\n  return local;\n}();\n\nvar isBrowser = typeof window !== 'undefined'; // tslint:disable-next-line:no-empty\n\nfunction noop() {}\n\nvar fakeDoc = {\n  createElement: noop,\n  createElementNS: noop,\n  createTextNode: noop\n};\nvar doc = isBrowser ? document : fakeDoc;\nvar UA = isBrowser && window.navigator.userAgent.toLowerCase();\nvar isMacSafari = isBrowser && UA && window.navigator.platform && /mac/i.test(window.navigator.platform) && /^((?!chrome|android).)*safari/i.test(UA);\nvar isTaro = isBrowser && !document.scripts;\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isiOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nvar isSupportSVG = isFunction(doc.createAttributeNS);\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isBoolean(arg) {\n  return arg === true || arg === false;\n}\n\nvar isArray = Array.isArray;\n\nfunction isObject(arg) {\n  return arg === Object(arg) && !isFunction(arg);\n}\n\nfunction isUndefined(o) {\n  return o === undefined;\n} // Object.is polyfill\n// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\n\nfunction objectIs(x, y) {\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } // eslint-disable-next-line no-self-compare\n\n\n  return x !== x && y !== y;\n}\n\nvar canUsePromise = 'Promise' in global && !isMacSafari;\nvar resolved;\n\nif (canUsePromise) {\n  resolved = Promise.resolve();\n}\n\nvar nextTick = function (fn) {\n  var args = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) args[len] = arguments[len + 1];\n\n  fn = isFunction(fn) ? fn.bind.apply(fn, [null].concat(args)) : fn;\n\n  if (canUsePromise) {\n    return resolved.then(fn);\n  }\n\n  var timerFunc = 'requestAnimationFrame' in global && !isMacSafari ? requestAnimationFrame : setTimeout;\n  timerFunc(fn);\n};\n/* istanbul ignore next */\n// tslint:disable-next-line\n\n\nObject.is = Object.is || function (x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  return x !== x && y !== y;\n};\n\nfunction shallowEqual(obj1, obj2) {\n  if (obj1 === null || obj2 === null) {\n    return false;\n  }\n\n  if (Object.is(obj1, obj2)) {\n    return true;\n  }\n\n  var obj1Keys = obj1 ? Object.keys(obj1) : [];\n  var obj2Keys = obj2 ? Object.keys(obj2) : [];\n\n  if (obj1Keys.length !== obj2Keys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < obj1Keys.length; i++) {\n    var obj1KeyItem = obj1Keys[i];\n\n    if (!obj2.hasOwnProperty(obj1KeyItem) || !Object.is(obj1[obj1KeyItem], obj2[obj1KeyItem])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar SimpleMap = function SimpleMap() {\n  this.cache = [];\n  this.size = 0;\n};\n\nSimpleMap.prototype.set = function set(k, v) {\n  var this$1 = this;\n  var len = this.cache.length;\n\n  if (!len) {\n    this.cache.push({\n      k: k,\n      v: v\n    });\n    this.size += 1;\n    return;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var item = this$1.cache[i];\n\n    if (item.k === k) {\n      item.v = v;\n      return;\n    }\n  }\n\n  this.cache.push({\n    k: k,\n    v: v\n  });\n  this.size += 1;\n};\n\nSimpleMap.prototype.get = function get(k) {\n  var this$1 = this;\n  var len = this.cache.length;\n\n  if (!len) {\n    return;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var item = this$1.cache[i];\n\n    if (item.k === k) {\n      return item.v;\n    }\n  }\n};\n\nSimpleMap.prototype.has = function has(k) {\n  var this$1 = this;\n  var len = this.cache.length;\n\n  if (!len) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    var item = this$1.cache[i];\n\n    if (item.k === k) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nSimpleMap.prototype['delete'] = function delete$1(k) {\n  var this$1 = this;\n  var len = this.cache.length;\n\n  for (var i = 0; i < len; i++) {\n    var item = this$1.cache[i];\n\n    if (item.k === k) {\n      this$1.cache.splice(i, 1);\n      this$1.size -= 1;\n      return true;\n    }\n  }\n\n  return false;\n};\n\nSimpleMap.prototype.clear = function clear() {\n  var this$1 = this;\n  var len = this.cache.length;\n  this.size = 0;\n\n  if (!len) {\n    return;\n  }\n\n  while (len) {\n    this$1.cache.pop();\n    len--;\n  }\n};\n\nvar MapClass = 'Map' in global ? Map : SimpleMap;\n\nfunction isAttrAnEvent(attr) {\n  return attr[0] === 'o' && attr[1] === 'n';\n}\n\nvar extend = function () {\n  if ('assign' in Object) {\n    return function (source, from) {\n      if (!from) {\n        return source;\n      }\n\n      Object.assign(source, from);\n      return source;\n    };\n  } else {\n    return function (source, from) {\n      if (!from) {\n        return source;\n      }\n\n      for (var key in from) {\n        if (from.hasOwnProperty(key)) {\n          source[key] = from[key];\n        }\n      }\n\n      return source;\n    };\n  }\n}();\n\nfunction clone(obj) {\n  return extend({}, obj);\n}\n\nvar Current = {\n  current: null,\n  index: 0\n};\nvar EMPTY_CHILDREN = [];\nvar EMPTY_OBJ = {};\n\nfunction isNullOrUndef(o) {\n  return o === undefined || o === null;\n}\n\nfunction isInvalid(o) {\n  return isNullOrUndef(o) || o === true || o === false;\n}\n\nfunction isVNode(node) {\n  return !isNullOrUndef(node) && node.vtype === 2\n  /* Node */\n  ;\n}\n\nfunction isVText(node) {\n  return !isNullOrUndef(node) && node.vtype === 1\n  /* Text */\n  ;\n}\n\nfunction isComponent(instance) {\n  return !isInvalid(instance) && instance.isReactComponent === EMPTY_OBJ;\n}\n\nfunction isPortal(vtype, node) {\n  return (vtype & 32\n  /* Portal */\n  ) > 0;\n}\n\nfunction isComposite(node) {\n  return !isNullOrUndef(node) && node.vtype === 4\n  /* Composite */\n  ;\n}\n\nfunction isValidElement(node) {\n  return !isNullOrUndef(node) && node.vtype;\n} // tslint:disable-next-line:no-empty\n\n\nfunction noop$1() {} // typescript will compile the enum's value for us.\n// eg.\n// Composite = 1 << 2  => Composite = 4\n\n\nvar VType;\n\n(function (VType) {\n  VType[VType[\"Text\"] = 1] = \"Text\";\n  VType[VType[\"Node\"] = 2] = \"Node\";\n  VType[VType[\"Composite\"] = 4] = \"Composite\";\n  VType[VType[\"Void\"] = 16] = \"Void\";\n  VType[VType[\"Portal\"] = 32] = \"Portal\";\n})(VType || (VType = {}));\n\nvar Ref = {\n  update: function update(lastVnode, nextVnode, domNode) {\n    var prevRef = lastVnode != null && lastVnode.ref;\n    var nextRef = nextVnode != null && nextVnode.ref;\n\n    if (prevRef !== nextRef) {\n      this.detach(lastVnode, prevRef, lastVnode.dom);\n      this.attach(nextVnode, nextRef, domNode);\n    }\n  },\n  attach: function attach(vnode, ref, domNode) {\n    var node = isComposite(vnode) ? vnode.component : domNode;\n\n    if (isFunction(ref)) {\n      var componentForCatcher = isComposite(vnode) ? vnode.component : vnode;\n      errorCatcher(function () {\n        ref(node);\n      }, componentForCatcher);\n    } else if (isString(ref)) {\n      var inst = vnode._owner;\n\n      if (inst && isFunction(inst.render)) {\n        inst.refs[ref] = node;\n      }\n    } else if (isObject(ref)) {\n      ref.current = node;\n    }\n  },\n  detach: function detach(vnode, ref, domNode) {\n    var node = isComposite(vnode) ? vnode.component : domNode;\n\n    if (isFunction(ref)) {\n      var componentForCatcher = isComposite(vnode) ? vnode.component : vnode;\n      errorCatcher(function () {\n        ref(null);\n      }, componentForCatcher);\n    } else if (isString(ref)) {\n      var inst = vnode._owner;\n\n      if (inst.refs[ref] === node && isFunction(inst.render)) {\n        delete inst.refs[ref];\n      }\n    } else if (isObject(ref)) {\n      ref.current = null;\n    }\n  }\n};\nvar defaultOptions = {\n  passive: false,\n  capture: false\n};\n\nvar eventListenerOptionsSupported = function () {\n  var supported = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supported = true;\n      }\n    });\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch (e) {\n    supported = false;\n  }\n\n  return supported;\n};\n\nfunction getDefaultPassiveOption() {\n  var passiveOption = !eventListenerOptionsSupported() ? false : defaultOptions;\n  return function () {\n    return passiveOption;\n  };\n}\n\nvar getPassiveOption = getDefaultPassiveOption();\nvar supportedPassiveEventMap = {\n  scroll: getPassiveOption(),\n  wheel: getPassiveOption(),\n  touchstart: getPassiveOption(),\n  touchmove: getPassiveOption(),\n  touchenter: getPassiveOption(),\n  touchend: getPassiveOption(),\n  touchleave: getPassiveOption(),\n  mouseout: getPassiveOption(),\n  mouseleave: getPassiveOption(),\n  mouseup: getPassiveOption(),\n  mousedown: getPassiveOption(),\n  mousemove: getPassiveOption(),\n  mouseenter: getPassiveOption(),\n  mousewheel: getPassiveOption(),\n  mouseover: getPassiveOption()\n};\nvar ONINPUT = 'oninput';\nvar ONPROPERTYCHANGE = 'onpropertychange';\nvar delegatedEvents = new MapClass();\nvar unbubbleEvents = {\n  onmousemove: 1,\n  ontouchmove: 1,\n  onmouseleave: 1,\n  onmouseenter: 1,\n  onload: 1,\n  onunload: 1,\n  onscroll: 1,\n  onfocus: 1,\n  onblur: 1,\n  onrowexit: 1,\n  onbeforeunload: 1,\n  onstop: 1,\n  ondragdrop: 1,\n  ondragenter: 1,\n  ondragexit: 1,\n  ondraggesture: 1,\n  ondragover: 1,\n  oncontextmenu: 1,\n  onerror: 1,\n  onabort: 1,\n  oncanplay: 1,\n  oncanplaythrough: 1,\n  ondurationchange: 1,\n  onemptied: 1,\n  onended: 1,\n  onloadeddata: 1,\n  onloadedmetadata: 1,\n  onloadstart: 1,\n  onencrypted: 1,\n  onpause: 1,\n  onplay: 1,\n  onplaying: 1,\n  onprogress: 1,\n  onratechange: 1,\n  onseeking: 1,\n  onseeked: 1,\n  onstalled: 1,\n  onsuspend: 1,\n  ontimeupdate: 1,\n  onvolumechange: 1,\n  onwaiting: 1\n};\nunbubbleEvents[ONPROPERTYCHANGE] = 1;\nvar bindFocus = false;\n/* istanbul ignore next */\n\nif (isIE9) {\n  var elements = [];\n  var values = [];\n  doc.addEventListener('selectionchange', function () {\n    var el = doc.activeElement;\n\n    if (detectCanUseOnInputNode(el)) {\n      var index = elements.indexOf(el);\n      var element = elements[index] || elements.push(el);\n\n      if (element.value !== values[index]) {\n        var ev = doc.createEvent('CustomEvent');\n        ev.initCustomEvent('input', true, true, undefined);\n        values[index] = element.value;\n        el.dispatchEvent(ev);\n      }\n    }\n  });\n}\n\nif (typeof Event !== 'undefined' && !Event.prototype.persist) {\n  // tslint:disable-next-line:no-empty\n  Event.prototype.persist = noop$1;\n}\n\nfunction attachEvent(domNode, eventName, handler) {\n  eventName = fixEvent(domNode, eventName);\n  /* istanbul ignore next */\n\n  if (eventName === ONPROPERTYCHANGE) {\n    processOnPropertyChangeEvent(domNode, handler);\n    return;\n  }\n\n  var delegatedRoots = delegatedEvents.get(eventName);\n\n  if (unbubbleEvents[eventName] === 1 || isTaro) {\n    if (!delegatedRoots) {\n      delegatedRoots = new MapClass();\n    }\n\n    var event = attachEventToNode(domNode, eventName, delegatedRoots);\n    delegatedEvents.set(eventName, delegatedRoots);\n\n    if (isFunction(handler)) {\n      delegatedRoots.set(domNode, {\n        eventHandler: handler,\n        event: event\n      });\n    }\n  } else {\n    if (!delegatedRoots) {\n      delegatedRoots = {\n        items: new MapClass()\n      };\n      delegatedRoots.event = attachEventToDocument(doc, eventName, delegatedRoots);\n      delegatedEvents.set(eventName, delegatedRoots);\n    }\n\n    if (isFunction(handler)) {\n      if (isiOS) {\n        domNode.onclick = noop$1;\n      }\n\n      delegatedRoots.items.set(domNode, handler);\n    }\n  }\n}\n\nfunction detachEvent(domNode, eventName, handler) {\n  eventName = fixEvent(domNode, eventName);\n\n  if (eventName === ONPROPERTYCHANGE) {\n    return;\n  }\n\n  var delegatedRoots = delegatedEvents.get(eventName);\n\n  if (unbubbleEvents[eventName] === 1 && delegatedRoots || isTaro) {\n    var event = delegatedRoots.get(domNode);\n\n    if (event) {\n      domNode.removeEventListener(parseEventName(eventName), event.event, false);\n      /* istanbul ignore next */\n\n      var delegatedRootsSize = delegatedRoots.size;\n\n      if (delegatedRoots['delete'](domNode) && delegatedRootsSize === 0) {\n        delegatedEvents['delete'](eventName);\n      }\n    }\n  } else if (delegatedRoots && delegatedRoots.items) {\n    var items = delegatedRoots.items;\n\n    if (items['delete'](domNode) && items.size === 0) {\n      doc.removeEventListener(parseEventName(eventName), delegatedRoots.event, false);\n      delegatedEvents['delete'](eventName);\n    }\n  }\n}\n\nvar propertyChangeActiveElement;\nvar propertyChangeActiveElementValue;\nvar propertyChangeActiveElementValueProp;\nvar propertyChangeActiveHandlers = {};\n/* istanbul ignore next */\n\nfunction propertyChangeHandler(event) {\n  if (event.propertyName !== 'value') {\n    return;\n  }\n\n  var target = event.target || event.srcElement;\n  var val = target.value;\n\n  if (val === propertyChangeActiveElementValue) {\n    return;\n  }\n\n  propertyChangeActiveElementValue = val;\n  var handler = propertyChangeActiveHandlers[target.name];\n\n  if (isFunction(handler)) {\n    handler.call(target, event);\n  }\n}\n/* istanbul ignore next */\n\n\nfunction processOnPropertyChangeEvent(node, handler) {\n  propertyChangeActiveHandlers[node.name] = handler;\n\n  if (!bindFocus) {\n    // bindFocus = true\n    node.addEventListener('focusin', function () {\n      unbindOnPropertyChange();\n      bindOnPropertyChange(node);\n    }, false);\n    node.addEventListener('focusout', unbindOnPropertyChange, false);\n  }\n}\n/* istanbul ignore next */\n\n\nfunction bindOnPropertyChange(node) {\n  propertyChangeActiveElement = node;\n  propertyChangeActiveElementValue = node.value;\n  propertyChangeActiveElementValueProp = Object.getOwnPropertyDescriptor(node.constructor.prototype, 'value');\n  Object.defineProperty(propertyChangeActiveElement, 'value', {\n    get: function get() {\n      return propertyChangeActiveElementValueProp.get.call(this);\n    },\n    set: function set(val) {\n      propertyChangeActiveElementValue = val;\n      propertyChangeActiveElementValueProp.set.call(this, val);\n    }\n  });\n  propertyChangeActiveElement.addEventListener('propertychange', propertyChangeHandler, false);\n}\n/* istanbul ignore next */\n\n\nfunction unbindOnPropertyChange() {\n  if (!propertyChangeActiveElement) {\n    return;\n  }\n\n  delete propertyChangeActiveElement.value;\n  propertyChangeActiveElement.removeEventListener('propertychange', propertyChangeHandler, false);\n  propertyChangeActiveElement = null;\n  propertyChangeActiveElementValue = null;\n  propertyChangeActiveElementValueProp = null;\n}\n\nfunction detectCanUseOnInputNode(node) {\n  var nodeName = node.nodeName && node.nodeName.toLowerCase();\n  var type = node.type;\n  return nodeName === 'input' && /text|password/.test(type) || nodeName === 'textarea';\n}\n\nfunction fixEvent(node, eventName) {\n  if (isTaro && eventName === 'onClick') {\n    eventName = 'onTap';\n  }\n\n  if (eventName === 'onDoubleClick') {\n    eventName = 'ondblclick';\n  } else if (eventName === 'onTouchTap') {\n    eventName = 'onclick'; // tslint:disable-next-line:prefer-conditional-expression\n  } else if (eventName === 'onChange' && detectCanUseOnInputNode(node)) {\n    eventName = ONINPUT in window ? ONINPUT : ONPROPERTYCHANGE;\n  } else {\n    eventName = eventName.toLowerCase();\n  }\n\n  return eventName;\n}\n\nfunction parseEventName(name) {\n  return name.substr(2);\n}\n/* istanbul ignore next */\n\n\nfunction stopPropagation() {\n  this.cancelBubble = true;\n  this.stopImmediatePropagation();\n}\n\nfunction dispatchEvent(event, target, items, count, eventData) {\n  var eventsToTrigger = items.get(target);\n\n  if (eventsToTrigger) {\n    count--;\n    eventData.currentTarget = target; // for React synthetic event compatibility\n\n    Object.defineProperties(event, {\n      nativeEvent: {\n        value: event\n      }\n    });\n    eventsToTrigger(event);\n\n    if (event.cancelBubble) {\n      return;\n    }\n  }\n\n  if (count > 0) {\n    var parentDom = target.parentNode;\n\n    if (parentDom === null || event.type === 'click' && parentDom.nodeType === 1 && parentDom.disabled) {\n      return;\n    }\n\n    dispatchEvent(event, parentDom, items, count, eventData);\n  }\n}\n\nfunction attachEventToDocument(d, eventName, delegatedRoots) {\n  var eventHandler = function (event) {\n    var items = delegatedRoots.items;\n    var count = items.size;\n\n    if (count > 0) {\n      var eventData = {\n        currentTarget: event.target\n      };\n      /* istanbul ignore next */\n\n      try {\n        Object.defineProperties(event, {\n          currentTarget: {\n            configurable: true,\n            get: function get() {\n              return eventData.currentTarget;\n            }\n          },\n          stopPropagation: {\n            value: stopPropagation\n          }\n        });\n      } catch (error) {// some browsers crashed\n        // see: https://stackoverflow.com/questions/44052813/why-cannot-redefine-property\n      }\n\n      dispatchEvent(event, event.target, delegatedRoots.items, count, eventData);\n    }\n  };\n\n  var parsedEventName = parseEventName(eventName);\n  d.addEventListener(parsedEventName, eventHandler, supportedPassiveEventMap[parsedEventName] || false);\n  return eventHandler;\n}\n\nfunction attachEventToNode(node, eventName, delegatedRoots) {\n  var eventHandler = function (event) {\n    var eventToTrigger = delegatedRoots.get(node);\n\n    if (eventToTrigger && eventToTrigger.eventHandler) {\n      var eventData = {\n        currentTarget: node\n      };\n      /* istanbul ignore next */\n\n      Object.defineProperties(event, {\n        currentTarget: {\n          configurable: true,\n          get: function get() {\n            return eventData.currentTarget;\n          }\n        }\n      });\n      eventToTrigger.eventHandler(event);\n    }\n  };\n\n  var parsedEventName = parseEventName(eventName);\n  node.addEventListener(parsedEventName, eventHandler, supportedPassiveEventMap[parsedEventName] || false);\n  return eventHandler;\n}\n\nfunction unmountChildren(children, parentDom) {\n  if (isArray(children)) {\n    for (var i = 0, len = children.length; i < len; i++) {\n      unmount(children[i], parentDom);\n    }\n  } else {\n    unmount(children, parentDom);\n  }\n}\n\nfunction unmount(vnode, parentDom) {\n  if (isInvalid(vnode)) {\n    return;\n  }\n\n  var vtype = vnode.vtype; // Bitwise operators for better performance\n  // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\n\n  var dom = vnode.dom;\n\n  if ((vtype & 4\n  /* Composite */\n  ) > 0) {\n    vnode.destroy();\n  } else if ((vtype & 2\n  /* Node */\n  ) > 0) {\n    var props = vnode.props;\n    var children = vnode.children;\n    var ref = vnode.ref;\n    unmountChildren(children);\n\n    for (var propName in props) {\n      if (isAttrAnEvent(propName)) {\n        detachEvent(dom, propName, props[propName]);\n      }\n    }\n\n    if (ref !== null) {\n      Ref.detach(vnode, ref, dom);\n    }\n  } else if (vtype & 32\n  /* Portal */\n  ) {\n      unmountChildren(vnode.children, vnode.type);\n    }\n\n  if (!isNullOrUndef(parentDom) && !isNullOrUndef(dom)) {\n    if (isArray(dom)) {\n      for (var i = 0; i < dom.length; i++) {\n        parentDom.removeChild(dom[i]);\n      }\n    } else {\n      parentDom.removeChild(dom);\n    }\n  } // vnode.dom = null\n\n}\n\nvar NS = {\n  ev: 'http://www.w3.org/2001/xml-events',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\nvar ATTRS = {\n  accentHeight: 'accent-height',\n  accumulate: 0,\n  additive: 0,\n  alignmentBaseline: 'alignment-baseline',\n  allowReorder: 'allowReorder',\n  alphabetic: 0,\n  amplitude: 0,\n  arabicForm: 'arabic-form',\n  ascent: 0,\n  attributeName: 'attributeName',\n  attributeType: 'attributeType',\n  autoReverse: 'autoReverse',\n  azimuth: 0,\n  baseFrequency: 'baseFrequency',\n  baseProfile: 'baseProfile',\n  baselineShift: 'baseline-shift',\n  bbox: 0,\n  begin: 0,\n  bias: 0,\n  by: 0,\n  calcMode: 'calcMode',\n  capHeight: 'cap-height',\n  clip: 0,\n  clipPath: 'clip-path',\n  clipRule: 'clip-rule',\n  clipPathUnits: 'clipPathUnits',\n  colorInterpolation: 'color-interpolation',\n  colorInterpolationFilters: 'color-interpolation-filters',\n  colorProfile: 'color-profile',\n  colorRendering: 'color-rendering',\n  contentScriptType: 'contentScriptType',\n  contentStyleType: 'contentStyleType',\n  cursor: 0,\n  cx: 0,\n  cy: 0,\n  d: 0,\n  decelerate: 0,\n  descent: 0,\n  diffuseConstant: 'diffuseConstant',\n  direction: 0,\n  display: 0,\n  divisor: 0,\n  dominantBaseline: 'dominant-baseline',\n  dur: 0,\n  dx: 0,\n  dy: 0,\n  edgeMode: 'edgeMode',\n  elevation: 0,\n  enableBackground: 'enable-background',\n  end: 0,\n  evEvent: 'ev:event',\n  exponent: 0,\n  externalResourcesRequired: 'externalResourcesRequired',\n  fill: 0,\n  fillOpacity: 'fill-opacity',\n  fillRule: 'fill-rule',\n  filter: 0,\n  filterRes: 'filterRes',\n  filterUnits: 'filterUnits',\n  floodColor: 'flood-color',\n  floodOpacity: 'flood-opacity',\n  focusable: 0,\n  fontFamily: 'font-family',\n  fontSize: 'font-size',\n  fontSizeAdjust: 'font-size-adjust',\n  fontStretch: 'font-stretch',\n  fontStyle: 'font-style',\n  fontVariant: 'font-variant',\n  fontWeight: 'font-weight',\n  format: 0,\n  from: 0,\n  fx: 0,\n  fy: 0,\n  g1: 0,\n  g2: 0,\n  glyphName: 'glyph-name',\n  glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n  glyphOrientationVertical: 'glyph-orientation-vertical',\n  glyphRef: 'glyphRef',\n  gradientTransform: 'gradientTransform',\n  gradientUnits: 'gradientUnits',\n  hanging: 0,\n  horizAdvX: 'horiz-adv-x',\n  horizOriginX: 'horiz-origin-x',\n  ideographic: 0,\n  imageRendering: 'image-rendering',\n  'in': 0,\n  in2: 0,\n  intercept: 0,\n  k: 0,\n  k1: 0,\n  k2: 0,\n  k3: 0,\n  k4: 0,\n  kernelMatrix: 'kernelMatrix',\n  kernelUnitLength: 'kernelUnitLength',\n  kerning: 0,\n  keyPoints: 'keyPoints',\n  keySplines: 'keySplines',\n  keyTimes: 'keyTimes',\n  lengthAdjust: 'lengthAdjust',\n  letterSpacing: 'letter-spacing',\n  lightingColor: 'lighting-color',\n  limitingConeAngle: 'limitingConeAngle',\n  local: 0,\n  markerEnd: 'marker-end',\n  markerMid: 'marker-mid',\n  markerStart: 'marker-start',\n  markerHeight: 'markerHeight',\n  markerUnits: 'markerUnits',\n  markerWidth: 'markerWidth',\n  mask: 0,\n  maskContentUnits: 'maskContentUnits',\n  maskUnits: 'maskUnits',\n  mathematical: 0,\n  mode: 0,\n  numOctaves: 'numOctaves',\n  offset: 0,\n  opacity: 0,\n  operator: 0,\n  order: 0,\n  orient: 0,\n  orientation: 0,\n  origin: 0,\n  overflow: 0,\n  overlinePosition: 'overline-position',\n  overlineThickness: 'overline-thickness',\n  paintOrder: 'paint-order',\n  panose1: 'panose-1',\n  pathLength: 'pathLength',\n  patternContentUnits: 'patternContentUnits',\n  patternTransform: 'patternTransform',\n  patternUnits: 'patternUnits',\n  pointerEvents: 'pointer-events',\n  points: 0,\n  pointsAtX: 'pointsAtX',\n  pointsAtY: 'pointsAtY',\n  pointsAtZ: 'pointsAtZ',\n  preserveAlpha: 'preserveAlpha',\n  preserveAspectRatio: 'preserveAspectRatio',\n  primitiveUnits: 'primitiveUnits',\n  r: 0,\n  radius: 0,\n  refX: 'refX',\n  refY: 'refY',\n  renderingIntent: 'rendering-intent',\n  repeatCount: 'repeatCount',\n  repeatDur: 'repeatDur',\n  requiredExtensions: 'requiredExtensions',\n  requiredFeatures: 'requiredFeatures',\n  restart: 0,\n  result: 0,\n  rotate: 0,\n  rx: 0,\n  ry: 0,\n  scale: 0,\n  seed: 0,\n  shapeRendering: 'shape-rendering',\n  slope: 0,\n  spacing: 0,\n  specularConstant: 'specularConstant',\n  specularExponent: 'specularExponent',\n  speed: 0,\n  spreadMethod: 'spreadMethod',\n  startOffset: 'startOffset',\n  stdDeviation: 'stdDeviation',\n  stemh: 0,\n  stemv: 0,\n  stitchTiles: 'stitchTiles',\n  stopColor: 'stop-color',\n  stopOpacity: 'stop-opacity',\n  strikethroughPosition: 'strikethrough-position',\n  strikethroughThickness: 'strikethrough-thickness',\n  string: 0,\n  stroke: 0,\n  strokeDasharray: 'stroke-dasharray',\n  strokeDashoffset: 'stroke-dashoffset',\n  strokeLinecap: 'stroke-linecap',\n  strokeLinejoin: 'stroke-linejoin',\n  strokeMiterlimit: 'stroke-miterlimit',\n  strokeOpacity: 'stroke-opacity',\n  strokeWidth: 'stroke-width',\n  surfaceScale: 'surfaceScale',\n  systemLanguage: 'systemLanguage',\n  tableValues: 'tableValues',\n  targetX: 'targetX',\n  targetY: 'targetY',\n  textAnchor: 'text-anchor',\n  textDecoration: 'text-decoration',\n  textRendering: 'text-rendering',\n  textLength: 'textLength',\n  to: 0,\n  transform: 0,\n  u1: 0,\n  u2: 0,\n  underlinePosition: 'underline-position',\n  underlineThickness: 'underline-thickness',\n  unicode: 0,\n  unicodeBidi: 'unicode-bidi',\n  unicodeRange: 'unicode-range',\n  unitsPerEm: 'units-per-em',\n  vAlphabetic: 'v-alphabetic',\n  vHanging: 'v-hanging',\n  vIdeographic: 'v-ideographic',\n  vMathematical: 'v-mathematical',\n  values: 0,\n  vectorEffect: 'vector-effect',\n  version: 0,\n  vertAdvY: 'vert-adv-y',\n  vertOriginX: 'vert-origin-x',\n  vertOriginY: 'vert-origin-y',\n  viewBox: 'viewBox',\n  viewTarget: 'viewTarget',\n  visibility: 0,\n  widths: 0,\n  wordSpacing: 'word-spacing',\n  writingMode: 'writing-mode',\n  x: 0,\n  xHeight: 'x-height',\n  x1: 0,\n  x2: 0,\n  xChannelSelector: 'xChannelSelector',\n  xlinkActuate: 'xlink:actuate',\n  xlinkArcrole: 'xlink:arcrole',\n  xlinkHref: 'xlink:href',\n  xlinkRole: 'xlink:role',\n  xlinkShow: 'xlink:show',\n  xlinkTitle: 'xlink:title',\n  xlinkType: 'xlink:type',\n  xmlBase: 'xml:base',\n  xmlId: 'xml:id',\n  xmlns: 0,\n  xmlnsXlink: 'xmlns:xlink',\n  xmlLang: 'xml:lang',\n  xmlSpace: 'xml:space',\n  y: 0,\n  y1: 0,\n  y2: 0,\n  yChannelSelector: 'yChannelSelector',\n  z: 0,\n  zoomAndPan: 'zoomAndPan'\n};\nvar SVGPropertyConfig = {\n  Properties: {},\n  DOMAttributeNamespaces: {\n    'ev:event': NS.ev,\n    'xlink:actuate': NS.xlink,\n    'xlink:arcrole': NS.xlink,\n    'xlink:href': NS.xlink,\n    'xlink:role': NS.xlink,\n    'xlink:show': NS.xlink,\n    'xlink:title': NS.xlink,\n    'xlink:type': NS.xlink,\n    'xml:base': NS.xml,\n    'xml:id': NS.xml,\n    'xml:lang': NS.xml,\n    'xml:space': NS.xml\n  },\n  DOMAttributeNames: {}\n};\nObject.keys(ATTRS).forEach(function (key) {\n  SVGPropertyConfig.Properties[key] = 0;\n\n  if (ATTRS[key]) {\n    SVGPropertyConfig.DOMAttributeNames[key] = ATTRS[key];\n  }\n});\n/* tslint:disable: no-empty*/\n\nfunction patch(lastVnode, nextVnode, parentNode, context, isSvg) {\n  var lastDom = lastVnode.dom;\n  var newDom;\n  var lastVnodeIsArray = isArray(lastVnode);\n  var nextVnodeisArray = isArray(nextVnode);\n\n  if (isSameVNode(lastVnode, nextVnode)) {\n    var vtype = nextVnode.vtype;\n\n    if (vtype & 2\n    /* Node */\n    ) {\n        isSvg = isNullOrUndef(isSvg) ? lastVnode.isSvg : isSvg;\n\n        if (isSvg) {\n          nextVnode.isSvg = isSvg;\n        }\n\n        patchProps(lastDom, nextVnode.props, lastVnode.props, lastVnode, isSvg);\n        patchChildren(lastDom, lastVnode.children, nextVnode.children, context, isSvg);\n\n        if (nextVnode.ref !== null) {\n          Ref.update(lastVnode, nextVnode, lastDom);\n        }\n\n        newDom = lastDom;\n      } else if ((vtype & 4\n    /* Composite */\n    ) > 0) {\n      newDom = nextVnode.update(lastVnode, nextVnode, context);\n    } else if (vtype & 1\n    /* Text */\n    ) {\n        return patchVText(lastVnode, nextVnode);\n      } else if (vtype & 32\n    /* Portal */\n    ) {\n        patchChildren(lastVnode.type, lastVnode.children, nextVnode.children, context, isSvg);\n      } // @TODO: test case\n\n\n    nextVnode.dom = newDom || lastDom;\n  } else if (isArray(lastVnode) && isArray(nextVnode)) {\n    patchArrayChildren(lastDom, lastVnode, nextVnode, context, false);\n  } else if (lastVnodeIsArray && !nextVnodeisArray) {\n    patchArrayChildren(parentNode, lastVnode, [nextVnode], context, false);\n  } else if (!lastVnodeIsArray && nextVnodeisArray) {\n    newDom = createElement(nextVnode, isSvg, context);\n    insertElement(newDom, parentNode, lastDom);\n    parentNode.removeChild(lastDom);\n  } else {\n    unmount(lastVnode);\n    newDom = createElement(nextVnode, isSvg, context);\n\n    if (nextVnode !== null) {\n      nextVnode.dom = newDom;\n    }\n\n    var newDomIsArray = isArray(newDom);\n    var lastDomIsArray = isArray(lastDom);\n\n    if (newDomIsArray) {\n      insertElement(newDom, parentNode, lastDom);\n      parentNode.removeChild(lastDom);\n    } else if (lastDomIsArray) {\n      parentNode = lastDom[0].parentNode;\n      parentNode.insertBefore(newDom, lastDom[0]);\n\n      for (var i = 0; i < lastDom.length; i++) {\n        parentNode.removeChild(lastDom[i]);\n      }\n    } else if (parentNode !== null) {\n      if (lastDom != null) {\n        parentNode.replaceChild(newDom, lastDom);\n      } else {\n        parentNode.appendChild(newDom);\n      }\n    }\n  }\n\n  return newDom;\n}\n\nfunction patchArrayChildren(parentDom, lastChildren, nextChildren, context, isSvg) {\n  var lastLength = lastChildren.length;\n  var nextLength = nextChildren.length;\n\n  if (lastLength === 0) {\n    if (nextLength > 0) {\n      for (var i = 0; i < nextLength; i++) {\n        mountChild(nextChildren[i], parentDom, context, isSvg);\n      }\n    }\n  } else if (nextLength === 0) {\n    unmountChildren(lastChildren);\n    parentDom.textContent = '';\n  } else {\n    if (isKeyed(lastChildren, nextChildren)) {\n      patchKeyedChildren(lastChildren, nextChildren, parentDom, context, isSvg, lastLength, nextLength);\n    } else {\n      patchNonKeyedChildren(parentDom, lastChildren, nextChildren, context, isSvg, lastLength, nextLength);\n    }\n  }\n}\n\nfunction patchChildren(parentDom, lastChildren, nextChildren, context, isSvg) {\n  // @TODO: is a better way to compatible with react-router?\n  // if (lastChildren === nextChildren) {\n  //   return\n  // }\n  var lastChildrenIsArray = isArray(lastChildren);\n  var nextChildrenIsArray = isArray(nextChildren);\n\n  if (lastChildrenIsArray && nextChildrenIsArray) {\n    patchArrayChildren(parentDom, lastChildren, nextChildren, context, isSvg);\n  } else if (!lastChildrenIsArray && !nextChildrenIsArray) {\n    patch(lastChildren, nextChildren, parentDom, context, isSvg);\n  } else if (lastChildrenIsArray && !nextChildrenIsArray) {\n    patchArrayChildren(parentDom, lastChildren, [nextChildren], context, isSvg);\n  } else if (!lastChildrenIsArray && nextChildrenIsArray) {\n    patchArrayChildren(parentDom, [lastChildren], nextChildren, context, isSvg);\n  }\n}\n\nfunction patchNonKeyedChildren(parentDom, lastChildren, nextChildren, context, isSvg, lastLength, nextLength) {\n  var minLength = Math.min(lastLength, nextLength);\n  var i = 0;\n\n  while (i < minLength) {\n    patch(lastChildren[i], nextChildren[i], parentDom, context, isSvg);\n    i++;\n  }\n\n  if (lastLength < nextLength) {\n    for (i = minLength; i < nextLength; i++) {\n      if (parentDom !== null) {\n        var refVnode = lastChildren[i - 1];\n        mountElement(createElement(nextChildren[i], isSvg, context), parentDom, isValidElement(refVnode) && refVnode.dom != null ? refVnode.dom.nextSibling : null);\n      }\n    }\n  } else if (lastLength > nextLength) {\n    for (i = minLength; i < lastLength; i++) {\n      unmount(lastChildren[i], parentDom);\n    }\n  }\n}\n/**\r\n *\r\n * Virtual DOM patching algorithm based on ivi by\r\n * Boris Kaul (@localvoid)\r\n * Licensed under the MIT License\r\n * https://github.com/ivijs/ivi/blob/master/LICENSE\r\n *\r\n */\n\n\nfunction patchKeyedChildren(a, b, dom, context, isSvg, aLength, bLength) {\n  var aEnd = aLength - 1;\n  var bEnd = bLength - 1;\n  var aStart = 0;\n  var bStart = 0;\n  var i;\n  var j;\n  var aNode;\n  var bNode;\n  var nextNode;\n  var nextPos;\n  var node;\n  var aStartNode = a[aStart];\n  var bStartNode = b[bStart];\n  var aEndNode = a[aEnd];\n  var bEndNode = b[bEnd]; // Step 1\n  // tslint:disable-next-line\n\n  outer: {\n    // Sync nodes with the same key at the beginning.\n    while (aStartNode.key === bStartNode.key) {\n      patch(aStartNode, bStartNode, dom, context, isSvg);\n      aStart++;\n      bStart++;\n\n      if (aStart > aEnd || bStart > bEnd) {\n        break outer;\n      }\n\n      aStartNode = a[aStart];\n      bStartNode = b[bStart];\n    } // Sync nodes with the same key at the end.\n\n\n    while (aEndNode.key === bEndNode.key) {\n      patch(aEndNode, bEndNode, dom, context, isSvg);\n      aEnd--;\n      bEnd--;\n\n      if (aStart > aEnd || bStart > bEnd) {\n        break outer;\n      }\n\n      aEndNode = a[aEnd];\n      bEndNode = b[bEnd];\n    }\n  }\n\n  if (aStart > aEnd) {\n    if (bStart <= bEnd) {\n      nextPos = bEnd + 1;\n      nextNode = nextPos < bLength ? b[nextPos].dom : null;\n\n      while (bStart <= bEnd) {\n        node = b[bStart];\n        bStart++;\n        attachNewNode(dom, createElement(node, isSvg, context), nextNode);\n      }\n    }\n  } else if (bStart > bEnd) {\n    while (aStart <= aEnd) {\n      unmount(a[aStart++], dom);\n    }\n  } else {\n    var aLeft = aEnd - aStart + 1;\n    var bLeft = bEnd - bStart + 1;\n    var sources = new Array(bLeft); // Mark all nodes as inserted.\n\n    for (i = 0; i < bLeft; i++) {\n      sources[i] = -1;\n    }\n\n    var moved = false;\n    var pos = 0;\n    var patched = 0; // When sizes are small, just loop them through\n\n    if (bLeft <= 4 || aLeft * bLeft <= 16) {\n      for (i = aStart; i <= aEnd; i++) {\n        aNode = a[i];\n\n        if (patched < bLeft) {\n          for (j = bStart; j <= bEnd; j++) {\n            bNode = b[j];\n\n            if (aNode.key === bNode.key) {\n              sources[j - bStart] = i;\n\n              if (pos > j) {\n                moved = true;\n              } else {\n                pos = j;\n              }\n\n              patch(aNode, bNode, dom, context, isSvg);\n              patched++;\n              a[i] = null;\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      var keyIndex = new MapClass();\n\n      for (i = bStart; i <= bEnd; i++) {\n        keyIndex.set(b[i].key, i);\n      }\n\n      for (i = aStart; i <= aEnd; i++) {\n        aNode = a[i];\n\n        if (patched < bLeft) {\n          j = keyIndex.get(aNode.key);\n\n          if (j !== undefined) {\n            bNode = b[j];\n            sources[j - bStart] = i;\n\n            if (pos > j) {\n              moved = true;\n            } else {\n              pos = j;\n            }\n\n            patch(aNode, bNode, dom, context, isSvg);\n            patched++;\n            a[i] = null;\n          }\n        }\n      }\n    }\n\n    if (aLeft === aLength && patched === 0) {\n      unmountChildren(a);\n      dom.textContent = '';\n\n      while (bStart < bLeft) {\n        node = b[bStart];\n        bStart++;\n        attachNewNode(dom, createElement(node, isSvg, context), null);\n      }\n    } else {\n      i = aLeft - patched;\n\n      while (i > 0) {\n        aNode = a[aStart++];\n\n        if (aNode !== null) {\n          unmount(aNode, dom);\n          i--;\n        }\n      }\n\n      if (moved) {\n        var seq = lis(sources);\n        j = seq.length - 1;\n\n        for (i = bLeft - 1; i >= 0; i--) {\n          if (sources[i] === -1) {\n            pos = i + bStart;\n            node = b[pos];\n            nextPos = pos + 1;\n            attachNewNode(dom, createElement(node, isSvg, context), nextPos < bLength ? b[nextPos].dom : null);\n          } else {\n            if (j < 0 || i !== seq[j]) {\n              pos = i + bStart;\n              node = b[pos];\n              nextPos = pos + 1;\n              attachNewNode(dom, node.dom, nextPos < bLength ? b[nextPos].dom : null);\n            } else {\n              j--;\n            }\n          }\n        }\n      } else if (patched !== bLeft) {\n        for (i = bLeft - 1; i >= 0; i--) {\n          if (sources[i] === -1) {\n            pos = i + bStart;\n            node = b[pos];\n            nextPos = pos + 1;\n            attachNewNode(dom, createElement(node, isSvg, context), nextPos < bLength ? b[nextPos].dom : null);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachNewNode(parentDom, newNode, nextNode) {\n  if (isNullOrUndef(nextNode)) {\n    parentDom.appendChild(newNode);\n  } else {\n    parentDom.insertBefore(newNode, nextNode);\n  }\n}\n/**\r\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\r\n * new items.\r\n *\r\n * http://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\n *\r\n * @param a Array of numbers.\r\n * @returns Longest increasing subsequence.\r\n */\n\n\nfunction lis(a) {\n  var p = a.slice();\n  var result = [];\n  result.push(0);\n  var u;\n  var v;\n\n  for (var i = 0, il = a.length; i < il; ++i) {\n    if (a[i] === -1) {\n      continue;\n    }\n\n    var j = result[result.length - 1];\n\n    if (a[j] < a[i]) {\n      p[i] = j;\n      result.push(i);\n      continue;\n    }\n\n    u = 0;\n    v = result.length - 1;\n\n    while (u < v) {\n      var c = (u + v) / 2 | 0;\n\n      if (a[result[c]] < a[i]) {\n        u = c + 1;\n      } else {\n        v = c;\n      }\n    }\n\n    if (a[i] < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n\n      result[u] = i;\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\nfunction isKeyed(lastChildren, nextChildren) {\n  return nextChildren.length > 0 && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key) && lastChildren.length > 0 && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);\n}\n\nfunction isSameVNode(a, b) {\n  if (isInvalid(a) || isInvalid(b) || isArray(a) || isArray(b)) {\n    return false;\n  }\n\n  return a.type === b.type && a.vtype === b.vtype && a.key === b.key;\n}\n\nfunction patchVText(lastVNode, nextVNode) {\n  var dom = lastVNode.dom;\n\n  if (dom === null) {\n    return;\n  }\n\n  var nextText = nextVNode.text;\n  nextVNode.dom = dom;\n\n  if (lastVNode.text !== nextText) {\n    dom.nodeValue = nextText;\n  }\n\n  return dom;\n}\n\nvar skipProps = {\n  children: 1,\n  key: 1,\n  ref: 1,\n  owner: 1\n};\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\nfunction setStyle(domStyle, style, value) {\n  if (isNullOrUndef(value) || isNumber(value) && isNaN(value)) {\n    domStyle[style] = '';\n    return;\n  }\n\n  if (style === 'float') {\n    domStyle['cssFloat'] = value;\n    domStyle['styleFloat'] = value;\n    return;\n  }\n\n  domStyle[style] = !isNumber(value) || IS_NON_DIMENSIONAL.test(style) ? value : value + 'px';\n}\n\nfunction patchEvent(eventName, lastEvent, nextEvent, domNode) {\n  if (lastEvent !== nextEvent) {\n    if (isFunction(lastEvent)) {\n      detachEvent(domNode, eventName, lastEvent);\n    }\n\n    attachEvent(domNode, eventName, nextEvent);\n  }\n}\n\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n  var domStyle = dom.style;\n  var style;\n  var value;\n\n  if (isString(nextAttrValue)) {\n    domStyle.cssText = nextAttrValue;\n    return;\n  }\n\n  if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n    for (style in nextAttrValue) {\n      value = nextAttrValue[style];\n\n      if (value !== lastAttrValue[style]) {\n        setStyle(domStyle, style, value);\n      }\n    }\n\n    for (style in lastAttrValue) {\n      if (isNullOrUndef(nextAttrValue[style])) {\n        domStyle[style] = '';\n      }\n    }\n  } else {\n    for (style in nextAttrValue) {\n      value = nextAttrValue[style];\n      setStyle(domStyle, style, value);\n    }\n  }\n}\n\nfunction patchProp(domNode, prop, lastValue, nextValue, lastVnode, isSvg) {\n  // fix the value update for textarea/input\n  if (lastValue !== nextValue || prop === 'value') {\n    if (prop === 'className') {\n      prop = 'class';\n    }\n\n    if (skipProps[prop] === 1) {\n      return;\n    } else if (prop === 'class' && !isSvg) {\n      domNode.className = nextValue;\n    } else if (prop === 'dangerouslySetInnerHTML') {\n      var lastHtml = lastValue && lastValue.__html;\n      var nextHtml = nextValue && nextValue.__html;\n\n      if (lastHtml !== nextHtml) {\n        if (!isNullOrUndef(nextHtml)) {\n          if (isValidElement(lastVnode) && lastVnode.children !== EMPTY_CHILDREN) {\n            unmountChildren(lastVnode.children);\n            lastVnode.children = [];\n          }\n\n          domNode.innerHTML = nextHtml;\n        }\n      }\n    } else if (isAttrAnEvent(prop)) {\n      patchEvent(prop, lastValue, nextValue, domNode);\n    } else if (prop === 'style') {\n      patchStyle(lastValue, nextValue, domNode);\n    } else if (prop !== 'list' && prop !== 'type' && !isSvg && prop in domNode) {\n      setProperty(domNode, prop, nextValue == null ? '' : nextValue);\n\n      if (nextValue == null || nextValue === false) {\n        domNode.removeAttribute(prop);\n      }\n    } else if (isNullOrUndef(nextValue) || nextValue === false) {\n      domNode.removeAttribute(prop);\n    } else {\n      var namespace = SVGPropertyConfig.DOMAttributeNamespaces[prop];\n\n      if (isSvg && namespace) {\n        if (nextValue) {\n          domNode.setAttributeNS(namespace, prop, nextValue);\n        } else {\n          var colonPosition = prop.indexOf(':');\n          var localName = colonPosition > -1 ? prop.substr(colonPosition + 1) : prop;\n          domNode.removeAttributeNS(namespace, localName);\n        }\n      } else {\n        if (!isFunction(nextValue)) {\n          domNode.setAttribute(prop, nextValue);\n        } // WARNING: Non-event attributes with function values:\n        // https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#changes-in-detail\n\n      }\n    }\n  }\n}\n\nfunction setProperty(node, name, value) {\n  try {\n    node[name] = value;\n  } catch (e) {}\n}\n\nfunction patchProps(domNode, nextProps, previousProps, lastVnode, isSvg) {\n  for (var propName in previousProps) {\n    var value = previousProps[propName];\n\n    if (isNullOrUndef(nextProps[propName]) && !isNullOrUndef(value)) {\n      if (isAttrAnEvent(propName)) {\n        detachEvent(domNode, propName, value);\n      } else if (propName === 'dangerouslySetInnerHTML') {\n        domNode.textContent = '';\n      } else if (propName === 'className') {\n        domNode.removeAttribute('class');\n      } else {\n        domNode.removeAttribute(propName);\n      }\n    }\n  }\n\n  for (var propName$1 in nextProps) {\n    patchProp(domNode, propName$1, previousProps[propName$1], nextProps[propName$1], lastVnode, isSvg);\n  }\n}\n\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nfunction createElement(vnode, isSvg, parentContext, parentComponent) {\n  var domNode;\n\n  if (isValidElement(vnode)) {\n    var vtype = vnode.vtype;\n\n    if (vtype & 4\n    /* Composite */\n    ) {\n        domNode = vnode.init(parentContext, parentComponent);\n      } else if (vtype & 1\n    /* Text */\n    ) {\n        domNode = doc.createTextNode(vnode.text);\n        vnode.dom = domNode;\n      } else if (vtype & 2\n    /* Node */\n    ) {\n        domNode = mountVNode$1(vnode, isSvg, parentContext, parentComponent);\n      } else if (vtype & 16\n    /* Void */\n    ) {\n        domNode = vnode.dom = doc.createTextNode('');\n      } else if (isPortal(vtype, vnode)) {\n      vnode.type.appendChild(createElement(vnode.children, isSvg, parentContext, parentComponent));\n      domNode = doc.createTextNode('');\n    }\n  } else if (isString(vnode) || isNumber(vnode)) {\n    domNode = doc.createTextNode(vnode);\n  } else if (isNullOrUndef(vnode) || isBoolean(vnode)) {\n    domNode = doc.createTextNode('');\n  } else if (isArray(vnode)) {\n    domNode = vnode.map(function (child) {\n      return createElement(child, isSvg, parentContext, parentComponent);\n    });\n  } else {\n    throw new Error('Unsupported VNode.');\n  }\n\n  return domNode;\n}\n\nfunction mountVNode$1(vnode, isSvg, parentContext, parentComponent) {\n  if (vnode.isSvg) {\n    isSvg = true;\n  } else if (vnode.type === 'svg') {\n    isSvg = true;\n    /* istanbul ignore next */\n  } else if (!isSupportSVG) {\n    isSvg = false;\n  }\n\n  if (isSvg) {\n    vnode.namespace = SVG_NAMESPACE;\n    vnode.isSvg = isSvg;\n  }\n\n  var domNode = !isSvg ? doc.createElement(vnode.type) : doc.createElementNS(vnode.namespace, vnode.type);\n  setProps(domNode, vnode, isSvg);\n\n  if (vnode.type === 'foreignObject') {\n    isSvg = false;\n  }\n\n  var children = vnode.children;\n\n  if (isArray(children)) {\n    for (var i = 0, len = children.length; i < len; i++) {\n      mountChild(children[i], domNode, parentContext, isSvg, parentComponent);\n    }\n  } else {\n    mountChild(children, domNode, parentContext, isSvg, parentComponent);\n  }\n\n  vnode.dom = domNode;\n\n  if (vnode.ref !== null) {\n    Ref.attach(vnode, vnode.ref, domNode);\n  }\n\n  return domNode;\n}\n\nfunction mountChild(child, domNode, parentContext, isSvg, parentComponent) {\n  child.parentContext = parentContext || EMPTY_OBJ;\n  var childNode = createElement(child, isSvg, parentContext, parentComponent);\n  mountElement(childNode, domNode);\n}\n\nfunction mountElement(element, parentNode, refChild) {\n  if (isArray(element)) {\n    for (var i = 0; i < element.length; i++) {\n      var el = element[i];\n      mountElement(el, parentNode);\n    }\n  } else {\n    refChild != null ? parentNode.insertBefore(element, refChild) : parentNode.appendChild(element);\n  }\n}\n\nfunction insertElement(element, parentNode, lastDom) {\n  if (isArray(element)) {\n    for (var i = 0; i < element.length; i++) {\n      var el = element[i];\n      insertElement(el, parentNode, lastDom);\n    }\n  } else {\n    parentNode.insertBefore(element, lastDom);\n  }\n}\n\nfunction setProps(domNode, vnode, isSvg) {\n  var props = vnode.props;\n\n  for (var p in props) {\n    patchProp(domNode, p, null, props[p], null, isSvg);\n  }\n}\n\nfunction createVText(text) {\n  return {\n    text: text,\n    vtype: 1\n    /* Text */\n    ,\n    dom: null\n  };\n}\n\nfunction createVoid() {\n  return {\n    dom: null,\n    vtype: 16\n    /* Void */\n\n  };\n}\n\nfunction getHooks(index) {\n  if (Current.current === null) {\n    throw new Error(\"invalid hooks call: hooks can only be called in a stateless component.\");\n  }\n\n  var hooks = Current.current.hooks;\n\n  if (index >= hooks.length) {\n    hooks.push({});\n  }\n\n  return hooks[index];\n}\n\nfunction useState(initialState) {\n  if (isFunction(initialState)) {\n    initialState = initialState();\n  }\n\n  var hook = getHooks(Current.index++);\n\n  if (!hook.state) {\n    hook.component = Current.current;\n    hook.state = [initialState, function (action) {\n      hook.state[0] = isFunction(action) ? action(hook.state[0]) : action;\n      hook.component._disable = false;\n      hook.component.setState({});\n    }];\n  }\n\n  return hook.state;\n}\n\nfunction useReducer(reducer, initialState, initializer) {\n  if (isFunction(initialState)) {\n    initialState = initialState();\n  }\n\n  var hook = getHooks(Current.index++);\n\n  if (!hook.state) {\n    hook.component = Current.current;\n    hook.state = [isUndefined(initializer) ? initialState : initializer(initialState), function (action) {\n      hook.state[0] = reducer(hook.state[0], action);\n      hook.component._disable = false;\n      hook.component.setState({});\n    }];\n  }\n\n  return hook.state;\n}\n\nfunction areDepsChanged(prevDeps, deps) {\n  if (isNullOrUndef(prevDeps) || isNullOrUndef(deps)) {\n    return true;\n  }\n\n  return deps.some(function (d, i) {\n    return !objectIs(d, prevDeps[i]);\n  });\n}\n\nfunction invokeEffects(component, delay) {\n  if (delay === void 0) delay = false;\n  var effects = delay ? component.effects : component.layoutEffects;\n  effects.forEach(function (hook) {\n    if (isFunction(hook.cleanup)) {\n      hook.cleanup();\n    }\n\n    var result = hook.effect();\n\n    if (isFunction(result)) {\n      hook.cleanup = result;\n    }\n  });\n\n  if (delay) {\n    component.effects = [];\n  } else {\n    component.layoutEffects = [];\n  }\n}\n\nvar scheduleEffectComponents = [];\n\nfunction invokeScheduleEffects(component) {\n  if (!component._afterScheduleEffect) {\n    component._afterScheduleEffect = true;\n    scheduleEffectComponents.push(component);\n\n    if (scheduleEffectComponents.length === 1) {\n      nextTick(function () {\n        setTimeout(function () {\n          scheduleEffectComponents.forEach(function (c) {\n            c._afterScheduleEffect = false;\n            invokeEffects(c, true);\n          });\n          scheduleEffectComponents = [];\n        }, 0);\n      });\n    }\n  }\n}\n\nfunction useEffectImpl(effect, deps, delay) {\n  if (delay === void 0) delay = false;\n  var hook = getHooks(Current.index++);\n\n  if (areDepsChanged(hook.deps, deps)) {\n    hook.effect = effect;\n    hook.deps = deps;\n\n    if (delay) {\n      Current.current.effects = Current.current.effects.concat(hook);\n      invokeScheduleEffects(Current.current);\n    } else {\n      Current.current.layoutEffects = Current.current.layoutEffects.concat(hook);\n    }\n  }\n}\n\nfunction useEffect(effect, deps) {\n  useEffectImpl(effect, deps, true);\n}\n\nfunction useLayoutEffect(effect, deps) {\n  useEffectImpl(effect, deps);\n}\n\nfunction useRef(initialValue) {\n  var hook = getHooks(Current.index++);\n\n  if (!hook.ref) {\n    hook.ref = {\n      current: initialValue\n    };\n  }\n\n  return hook.ref;\n}\n\nfunction useMemo(factory, deps) {\n  var hook = getHooks(Current.index++);\n\n  if (areDepsChanged(hook.deps, deps)) {\n    hook.deps = deps;\n    hook.callback = factory;\n    hook.value = factory();\n  }\n\n  return hook.value;\n}\n\nfunction useCallback(callback, deps) {\n  return useMemo(function () {\n    return callback;\n  }, deps);\n}\n\nfunction useContext(context) {\n  var provider = Current.current.context[context._id];\n\n  if (isUndefined(provider)) {\n    return context._defaultValue;\n  }\n\n  var hook = getHooks(Current.index++); // should update when value changes with shouldComponentUpdate:false Component on top\n\n  if (isUndefined(hook.context)) {\n    hook.context = true;\n    var c = Current.current;\n    provider.on(function () {\n      return enqueueRender(c);\n    });\n  }\n\n  return provider.value;\n}\n\nfunction useImperativeHandle(ref, init, deps) {\n  useLayoutEffect(function () {\n    if (isFunction(ref)) {\n      ref(init());\n      return function () {\n        return ref(null);\n      };\n    } else if (!isUndefined(ref)) {\n      ref.current = init();\n      return function () {\n        delete ref.current;\n      };\n    }\n  }, isArray(deps) ? deps.concat([ref]) : undefined);\n} // import { extend, isFunction, isNumber, isString } from 'nerv-utils'\n\n\nvar readyComponents = [];\n\nfunction errorCatcher(fn, component) {\n  try {\n    return fn();\n  } catch (error) {\n    errorHandler(component, error);\n  }\n}\n\nfunction errorHandler(component, error) {\n  // if(!component) { throw error ; return }\n  var boundary;\n\n  while (true) {\n    var ref = component.constructor;\n    var getDerivedStateFromError = ref.getDerivedStateFromError;\n\n    if (isFunction(getDerivedStateFromError) || isFunction(component.componentDidCatch)) {\n      boundary = component;\n      break;\n    } else if (component._parentComponent) {\n      component = component._parentComponent;\n    } else {\n      break;\n    }\n  }\n\n  if (boundary) {\n    var ref$1 = boundary.constructor;\n    var getDerivedStateFromError$1 = ref$1.getDerivedStateFromError;\n    var _disable = boundary._disable;\n    boundary._disable = false;\n\n    if (isFunction(getDerivedStateFromError$1)) {\n      component.setState(getDerivedStateFromError$1(error));\n    } else if (isFunction(component.componentDidCatch)) {\n      boundary.componentDidCatch(error);\n    }\n\n    boundary._disable = _disable;\n  } else {\n    throw error;\n  }\n}\n\nfunction ensureVirtualNode(rendered) {\n  if (isNumber(rendered) || isString(rendered)) {\n    return createVText(rendered);\n  } else if (isInvalid(rendered)) {\n    return createVoid();\n  } else if (isArray(rendered)) {\n    rendered = rendered.length === 0 ? createVoid() : rendered.map(ensureVirtualNode);\n  }\n\n  return rendered;\n}\n\nfunction mountVNode(vnode, parentContext, parentComponent) {\n  return createElement(vnode, false, parentContext, parentComponent);\n}\n\nfunction getContextByContextType(vnode, parentContext) {\n  var contextType = vnode.type.contextType;\n  var hasContextType = !isUndefined(contextType);\n  var provider = hasContextType ? parentContext[contextType._id] : null;\n  var context = hasContextType ? !isNullOrUndef(provider) ? provider.value : contextType._defaultValue : parentContext;\n  return context;\n}\n\nfunction mountComponent(vnode, parentContext, parentComponent) {\n  var ref = vnode.ref;\n\n  if (vnode.type.prototype && vnode.type.prototype.render) {\n    var context = getContextByContextType(vnode, parentContext);\n    vnode.component = new vnode.type(vnode.props, context);\n  } else {\n    var c = new Component(vnode.props, parentContext);\n\n    c.render = function () {\n      return vnode.type.call(c, c.props, c.context);\n    };\n\n    vnode.component = c;\n  }\n\n  var component = vnode.component;\n  component.vnode = vnode;\n\n  if (isComponent(parentComponent)) {\n    component._parentComponent = parentComponent;\n  }\n\n  var newState = callGetDerivedStateFromProps(vnode.props, component.state, component);\n\n  if (!isUndefined(newState)) {\n    component.state = newState;\n  }\n\n  if (!hasNewLifecycle(component) && isFunction(component.componentWillMount)) {\n    errorCatcher(function () {\n      component.componentWillMount();\n    }, component);\n    component.state = component.getState();\n    component.clearCallBacks();\n  }\n\n  component._dirty = false;\n  var rendered = renderComponent(component);\n  rendered.parentVNode = vnode;\n  component._rendered = rendered;\n\n  if (!isNullOrUndef(ref)) {\n    Ref.attach(vnode, ref, vnode.dom);\n  }\n\n  var dom = vnode.dom = mountVNode(rendered, getChildContext(component, parentContext), component);\n  invokeEffects(component);\n\n  if (isFunction(component.componentDidMount)) {\n    readyComponents.push(component);\n  }\n\n  component._disable = false;\n  return dom;\n}\n\nfunction getChildContext(component, context) {\n  if (context === void 0) context = EMPTY_OBJ;\n\n  if (isFunction(component.getChildContext)) {\n    return extend(clone(context), component.getChildContext());\n  }\n\n  return clone(context);\n}\n\nfunction renderComponent(component) {\n  Current.current = component;\n  Current.index = 0;\n  invokeEffects(component, true);\n  var rendered;\n  errorCatcher(function () {\n    rendered = component.render();\n  }, component);\n  rendered = ensureVirtualNode(rendered);\n  Current.current = null;\n  return rendered;\n}\n\nfunction flushMount() {\n  if (!readyComponents.length) {\n    return;\n  } // @TODO: perf\n\n\n  var queue = readyComponents.slice(0);\n  readyComponents.length = 0;\n  queue.forEach(function (item) {\n    if (isFunction(item)) {\n      item();\n    } else if (item.componentDidMount) {\n      errorCatcher(function () {\n        item.componentDidMount();\n      }, item);\n    }\n  });\n}\n\nfunction getFragmentHostNode(children) {\n  var child = children[0];\n\n  if (isArray(child)) {\n    return getFragmentHostNode(child);\n  } else if (isComposite(child) && child.dom == null) {\n    return getFragmentHostNode(child.component._rendered);\n  }\n\n  return child != null ? child.dom : null;\n}\n\nfunction reRenderComponent(prev, current) {\n  var component = current.component = prev.component;\n  var nextProps = current.props;\n  var nextContext = current.context;\n  component._disable = true;\n\n  if (!hasNewLifecycle(component) && isFunction(component.componentWillReceiveProps)) {\n    errorCatcher(function () {\n      component.componentWillReceiveProps(nextProps, nextContext);\n    }, component);\n  }\n\n  component._disable = false;\n  component.prevProps = component.props;\n  component.prevState = component.state;\n  component.prevContext = component.context;\n  component.props = nextProps;\n  component.context = nextContext;\n\n  if (!isNullOrUndef(current.ref)) {\n    Ref.update(prev, current);\n  }\n\n  return updateComponent(component);\n}\n\nfunction callShouldComponentUpdate(props, state, context, component) {\n  var shouldUpdate = true;\n  errorCatcher(function () {\n    shouldUpdate = component.shouldComponentUpdate(props, state, context);\n  }, component);\n  return shouldUpdate;\n}\n\nfunction updateComponent(component, isForce) {\n  if (isForce === void 0) isForce = false;\n  var vnode = component.vnode;\n  var dom = vnode.dom;\n  var props = component.props;\n  var state = component.getState();\n  var context = component.context;\n  var prevProps = component.prevProps || props;\n  var prevState = component.prevState || component.state;\n  var prevContext = component.prevContext || context;\n  var stateFromProps = callGetDerivedStateFromProps(props, state, component);\n\n  if (!isUndefined(stateFromProps)) {\n    state = stateFromProps;\n  }\n\n  component.props = prevProps;\n  component.context = prevContext;\n  var skip = false;\n  var onSCU = props.onShouldComponentUpdate;\n\n  if (!isForce && (isFunction(component.shouldComponentUpdate) && callShouldComponentUpdate(props, state, context, component) === false || isFunction(onSCU) && onSCU(prevProps, props) === false)) {\n    skip = true;\n  } else if (!hasNewLifecycle(component) && isFunction(component.componentWillUpdate)) {\n    errorCatcher(function () {\n      component.componentWillUpdate(props, state, context);\n    }, component);\n  }\n\n  if (!isUndefined(stateFromProps)) {\n    component.state = stateFromProps;\n  }\n\n  component.props = props;\n  component.state = state;\n  component.context = context;\n  component._dirty = false;\n\n  if (!skip) {\n    var lastRendered = component._rendered;\n    var rendered = renderComponent(component);\n    rendered.parentVNode = vnode;\n    var childContext = getChildContext(component, context);\n    var snapshot = callGetSnapshotBeforeUpdate(prevProps, prevState, component);\n    var parentDom = lastRendered.dom && lastRendered.dom.parentNode;\n\n    if (isArray(lastRendered)) {\n      var hostNode = getFragmentHostNode(lastRendered);\n\n      if (hostNode != null) {\n        parentDom = lastRendered.dom = hostNode.parentNode;\n      }\n    }\n\n    dom = vnode.dom = patch(lastRendered, rendered, parentDom || null, childContext);\n    component._rendered = rendered;\n\n    if (isFunction(component.componentDidUpdate)) {\n      errorCatcher(function () {\n        component.componentDidUpdate(prevProps, prevState, snapshot);\n      }, component);\n    }\n\n    while (vnode = vnode.parentVNode) {\n      if ((vnode.vtype & 4\n      /* Composite */\n      ) > 0) {\n        vnode.dom = dom;\n      }\n    }\n  }\n\n  component.prevProps = component.props;\n  component.prevState = component.state;\n  component.prevContext = component.context;\n  component.clearCallBacks();\n  flushMount();\n  invokeEffects(component);\n  return dom;\n}\n\nfunction unmountComponent(vnode) {\n  var component = vnode.component;\n  component.hooks.forEach(function (hook) {\n    if (isFunction(hook.cleanup)) {\n      hook.cleanup();\n    }\n  });\n\n  if (isFunction(component.componentWillUnmount)) {\n    errorCatcher(function () {\n      component.componentWillUnmount();\n    }, component);\n  }\n\n  component._disable = true;\n  unmount(component._rendered);\n\n  if (!isNullOrUndef(vnode.ref)) {\n    Ref.detach(vnode, vnode.ref, vnode.dom);\n  }\n}\n\nfunction callGetDerivedStateFromProps(props, state, inst) {\n  var ref = inst.constructor;\n  var getDerivedStateFromProps = ref.getDerivedStateFromProps;\n  var newState; // @TODO show warning\n\n  errorCatcher(function () {\n    if (isFunction(getDerivedStateFromProps)) {\n      var partialState = getDerivedStateFromProps.call(null, props, state);\n\n      if (!isUndefined(partialState)) {\n        newState = extend(clone(state), partialState);\n      }\n    }\n  }, inst);\n  return newState;\n}\n\nfunction callGetSnapshotBeforeUpdate(props, state, inst) {\n  var getSnapshotBeforeUpdate = inst.getSnapshotBeforeUpdate;\n  var snapshot;\n  errorCatcher(function () {\n    if (isFunction(getSnapshotBeforeUpdate)) {\n      snapshot = getSnapshotBeforeUpdate.call(inst, props, state);\n    }\n  }, inst);\n  return snapshot;\n}\n\nfunction hasNewLifecycle(component) {\n  if (isFunction(component.constructor.getDerivedStateFromProps)) {\n    return true;\n  }\n\n  return false;\n}\n\nvar items = [];\n\nfunction enqueueRender(component) {\n  // tslint:disable-next-line:no-conditional-assignment\n  if (!component._dirty && (component._dirty = true) && items.push(component) === 1) {\n    nextTick(rerender);\n  }\n}\n\nfunction rerender(isForce) {\n  if (isForce === void 0) isForce = false;\n  var p;\n  var list = items;\n  items = []; // tslint:disable-next-line:no-conditional-assignment\n\n  while (p = list.pop()) {\n    if (p._dirty) {\n      updateComponent(p, isForce);\n    }\n  }\n}\n\nvar Component = function Component(props, context) {\n  this._dirty = true;\n  this._disable = true;\n  this._pendingStates = [];\n  this._pendingCallbacks = [];\n  this._afterScheduleEffect = false;\n  this.hooks = [];\n  this.effects = EMPTY_CHILDREN;\n  this.layoutEffects = EMPTY_CHILDREN;\n\n  if (!this.state) {\n    this.state = {};\n  }\n\n  this.props = props || {};\n  this.context = context || EMPTY_OBJ;\n  this.refs = {};\n};\n\nComponent.prototype.setState = function setState(state, callback) {\n  if (state) {\n    this._pendingStates.push(state);\n  }\n\n  if (isFunction(callback)) {\n    this._pendingCallbacks.push(callback);\n  }\n\n  if (!this._disable) {\n    enqueueRender(this);\n  }\n};\n\nComponent.prototype.getState = function getState() {\n  var this$1 = this; // tslint:disable-next-line:no-this-assignment\n\n  var ref = this;\n  var _pendingStates = ref._pendingStates;\n  var state = ref.state;\n  var props = ref.props;\n\n  if (!_pendingStates.length) {\n    return state;\n  }\n\n  var stateClone = clone(state);\n\n  var queue = _pendingStates.concat();\n\n  this._pendingStates.length = 0;\n  queue.forEach(function (nextState) {\n    if (isFunction(nextState)) {\n      nextState = nextState.call(this$1, state, props);\n    }\n\n    extend(stateClone, nextState);\n  });\n  return stateClone;\n};\n\nComponent.prototype.clearCallBacks = function clearCallBacks() {\n  var this$1 = this; // cached the length of callbacks, or callbacks may increase by calling them in the same loop\n\n  var len = this._pendingCallbacks.length;\n\n  while (this._dirty ? this._pendingCallbacks.length : len) {\n    var cb = this$1._pendingCallbacks.shift();\n\n    cb.call(this$1);\n    len--;\n  }\n};\n\nComponent.prototype.forceUpdate = function forceUpdate(callback) {\n  if (isFunction(callback)) {\n    this._pendingCallbacks.push(callback);\n  }\n\n  updateComponent(this, true);\n}; // tslint:disable-next-line\n\n\nComponent.prototype.render = function render(nextProps, nextState, nextContext) {};\n\nComponent.prototype.isReactComponent = EMPTY_OBJ;\n\nvar PureComponent = function (Component$$1) {\n  function PureComponent() {\n    Component$$1.apply(this, arguments);\n    this.isPureComponent = true;\n  }\n\n  if (Component$$1) PureComponent.__proto__ = Component$$1;\n  PureComponent.prototype = Object.create(Component$$1 && Component$$1.prototype);\n  PureComponent.prototype.constructor = PureComponent;\n\n  PureComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\n  };\n\n  return PureComponent;\n}(Component);\n\nvar options = {\n  afterMount: noop$1,\n  afterUpdate: noop$1,\n  beforeUpdate: noop$1,\n  beforeUnmount: noop$1,\n  beforeRender: noop$1,\n  beforeMount: noop$1,\n  afterCreate: noop$1,\n  roots: [],\n  debug: false\n};\n\nfunction render(vnode, container, callback) {\n  if (!container) {\n    throw new Error(container + \" should be a DOM Element\");\n  }\n\n  var lastVnode = container._component;\n  var dom;\n  options.roots.push(vnode);\n\n  if (lastVnode !== undefined) {\n    options.roots = options.roots.filter(function (item) {\n      return item !== lastVnode;\n    });\n    dom = patch(lastVnode, vnode, container, {});\n  } else {\n    dom = mountVNode(vnode, {});\n    mountElement(dom, container);\n  }\n\n  if (container) {\n    container._component = vnode;\n  }\n\n  flushMount();\n\n  if (callback) {\n    callback();\n  }\n\n  return isComposite(vnode) ? vnode.component : dom;\n}\n\nfunction createVNode(type, props, children, key, namespace, owner, ref) {\n  return {\n    type: type,\n    key: key || null,\n    vtype: 2\n    /* Node */\n    ,\n    props: props || EMPTY_OBJ,\n    children: children,\n    namespace: namespace || null,\n    _owner: owner,\n    dom: null,\n    ref: ref || null\n  };\n}\n\nfunction h(type, props, children) {\n  var childNodes;\n\n  if (props.children) {\n    if (!children) {\n      children = props.children;\n    }\n  }\n\n  if (isArray(children)) {\n    childNodes = [];\n    addChildren(childNodes, children, type);\n  } else if (isString(children) || isNumber(children)) {\n    children = createVText(String(children));\n  } else if (!isValidElement(children)) {\n    children = EMPTY_CHILDREN;\n  }\n\n  props.children = childNodes !== undefined ? childNodes : children;\n  return createVNode(type, props, props.children, props.key, props.namespace, props.owner, props.ref);\n}\n\nfunction addChildren(childNodes, children, type) {\n  if (isString(children) || isNumber(children)) {\n    childNodes.push(createVText(String(children)));\n  } else if (isValidElement(children)) {\n    childNodes.push(children);\n  } else if (isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      addChildren(childNodes, children[i], type);\n    }\n  } else {\n    childNodes.push(createVoid());\n  }\n}\n\nvar ComponentWrapper = function ComponentWrapper(type, props) {\n  this.vtype = 4\n  /* Composite */\n  ;\n  this.type = type;\n  this.name = type.name;\n\n  if (isUndefined(this.name)) {\n    var names = type.toString().match(/^function\\s*([^\\s(]+)/);\n    this.name = isArray(names) ? names[0] : 'Component';\n  }\n\n  type.displayName = this.name;\n  this._owner = props.owner;\n  delete props.owner;\n\n  if (this.ref = props.ref) {\n    delete props.ref;\n  }\n\n  if (type._forwarded) {\n    if (!isUndefined(this.ref)) {\n      props.ref = this.ref;\n    }\n\n    delete this.ref;\n  }\n\n  this.props = props;\n  this.key = props.key || null;\n  this.dom = null;\n  options.afterCreate(this);\n};\n\nComponentWrapper.prototype.init = function init(parentContext, parentComponent) {\n  options.beforeMount(this);\n  var dom = mountComponent(this, parentContext, parentComponent);\n  options.afterMount(this);\n  return dom;\n};\n\nComponentWrapper.prototype.update = function update(previous, current, parentContext, domNode) {\n  this.context = getContextByContextType(this, parentContext);\n  options.beforeUpdate(this);\n  var dom = reRenderComponent(previous, this);\n  options.afterUpdate(this);\n  return dom;\n};\n\nComponentWrapper.prototype.destroy = function destroy() {\n  options.beforeUnmount(this);\n  unmountComponent(this);\n}; // import StatelessComponent from './stateless-component'\n\n\nfunction transformPropsForRealTag(type, props) {\n  var newProps = {};\n\n  for (var propName in props) {\n    var propValue = props[propName];\n\n    if (propName === 'defaultValue') {\n      newProps.value = props.value || props.defaultValue;\n      continue;\n    }\n\n    var svgPropName = SVGPropertyConfig.DOMAttributeNames[propName];\n\n    if (svgPropName && svgPropName !== propName) {\n      newProps[svgPropName] = propValue;\n      continue;\n    }\n\n    newProps[propName] = propValue;\n  }\n\n  return newProps;\n}\n/**\r\n *\r\n * @param props\r\n * @param defaultProps\r\n * defaultProps should respect null but ignore undefined\r\n * @see: https://facebook.github.io/react/docs/react-component.html#defaultprops\r\n */\n\n\nfunction transformPropsForComponent(props, defaultProps) {\n  var newProps = {};\n\n  for (var propName in props) {\n    var propValue = props[propName];\n    newProps[propName] = propValue;\n  }\n\n  if (defaultProps) {\n    for (var propName$1 in defaultProps) {\n      if (isUndefined(newProps[propName$1])) {\n        newProps[propName$1] = defaultProps[propName$1];\n      }\n    }\n  }\n\n  return newProps;\n}\n\nfunction createElement$2(type, properties) {\n  var _children = [],\n      len = arguments.length - 2;\n\n  while (len-- > 0) _children[len] = arguments[len + 2];\n\n  var children = _children;\n\n  if (_children) {\n    if (_children.length === 1) {\n      children = _children[0];\n    } else if (_children.length === 0) {\n      children = undefined;\n    }\n  }\n\n  var props;\n\n  if (isString(type)) {\n    props = transformPropsForRealTag(type, properties);\n    props.owner = Current.current;\n    return h(type, props, children);\n  } else if (isFunction(type)) {\n    props = transformPropsForComponent(properties, type.defaultProps);\n\n    if (!props.children || props.children === EMPTY_CHILDREN) {\n      props.children = children || children === 0 ? children : EMPTY_CHILDREN;\n    }\n\n    props.owner = Current.current;\n    return new ComponentWrapper(type, props);\n  }\n\n  return type;\n}\n\nfunction cloneElement(vnode, props) {\n  var children = [],\n      len = arguments.length - 2;\n\n  while (len-- > 0) children[len] = arguments[len + 2];\n\n  if (isVText(vnode)) {\n    return createVText(vnode.text);\n  }\n\n  if (isString(vnode) || isNumber(vnode)) {\n    return createVText(vnode);\n  }\n\n  if (isInvalid(vnode) || !isInvalid(vnode) && isPortal(vnode.vtype, vnode) || vnode && vnode.vtype & 16\n  /* Void */\n  ) {\n      return createVoid();\n    }\n\n  var properties = clone(extend(clone(vnode.props), props));\n\n  if (vnode.namespace) {\n    properties.namespace = vnode.namespace;\n  }\n\n  if (vnode.vtype & 4\n  /* Composite */\n  && !isNullOrUndef(vnode.ref)) {\n    properties.ref = vnode.ref;\n  }\n\n  var childrenTmp = (arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children || properties.children) || [];\n\n  if (childrenTmp.length) {\n    if (childrenTmp.length === 1) {\n      childrenTmp = children[0];\n    }\n  }\n\n  if (isArray(vnode)) {\n    return vnode.map(function (item) {\n      return cloneElement(item);\n    });\n  }\n\n  var newVNode = createElement$2(vnode.type, properties);\n\n  if (isArray(childrenTmp)) {\n    var _children = childrenTmp.map(function (child) {\n      return cloneElement(child, child.props);\n    });\n\n    if (_children.length === 0) {\n      _children = EMPTY_CHILDREN;\n    }\n\n    if (isVNode(newVNode)) {\n      newVNode.children = _children;\n    }\n\n    newVNode.props.children = _children;\n  } else if (childrenTmp) {\n    if (isVNode(newVNode)) {\n      newVNode.children = cloneElement(childrenTmp);\n    }\n\n    newVNode.props.children = cloneElement(childrenTmp, childrenTmp.props);\n  }\n\n  return newVNode;\n}\n\nvar Children = {\n  map: function map(children, fn, ctx) {\n    if (isNullOrUndef(children)) {\n      return children;\n    }\n\n    children = Children.toArray(children);\n\n    if (ctx && ctx !== children) {\n      fn = fn.bind(ctx);\n    }\n\n    return children.map(fn);\n  },\n  forEach: function forEach(children, fn, ctx) {\n    if (isNullOrUndef(children)) {\n      return;\n    }\n\n    children = Children.toArray(children);\n\n    if (ctx && ctx !== children) {\n      fn = fn.bind(ctx);\n    }\n\n    for (var i = 0, len = children.length; i < len; i++) {\n      var child = isInvalid(children[i]) ? null : children[i];\n      fn(child, i, children);\n    }\n  },\n  count: function count(children) {\n    children = Children.toArray(children);\n    return children.length;\n  },\n  only: function only(children) {\n    children = Children.toArray(children);\n\n    if (children.length !== 1) {\n      throw new Error('Children.only() expects only one child.');\n    }\n\n    return children[0];\n  },\n  toArray: function toArray(children) {\n    if (isNullOrUndef(children)) {\n      return [];\n    }\n\n    if (isArray(children)) {\n      var result = [];\n      flatten(children, result);\n      return result;\n    }\n\n    return EMPTY_CHILDREN.concat(children);\n  }\n};\n\nfunction flatten(arr, result) {\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var value = arr[i];\n\n    if (isArray(value)) {\n      flatten(value, result);\n    } else {\n      result.push(value);\n    }\n  }\n\n  return result;\n} // tslint:disable:no-conditional-assignment\n\n\nfunction hydrate(vnode, container, callback) {\n  if (container !== null) {\n    // lastChild causes less reflow than firstChild\n    var dom = container.lastChild; // there should be only a single entry for the root\n\n    while (dom) {\n      var next = dom.previousSibling;\n      container.removeChild(dom);\n      dom = next;\n    }\n\n    return render(vnode, container, callback);\n  }\n}\n\nfunction createPortal(children, container) {\n  return {\n    type: container,\n    vtype: 32\n    /* Portal */\n    ,\n    children: children,\n    dom: null\n  };\n} // some library check React version\n// see: https://github.com/NervJS/nerv/issues/46\n\n\nvar version = '15.4.2';\n\nfunction unmountComponentAtNode(dom) {\n  var component = dom._component;\n\n  if (isValidElement(component)) {\n    unmount(component, dom);\n    delete dom._component;\n    return true;\n  }\n\n  return false;\n}\n\nfunction findDOMNode(component) {\n  if (isInvalid(component)) {\n    return null;\n  }\n\n  return isComponent(component) ? component.vnode.dom : isValidElement(component) ? component.dom : component;\n}\n\nfunction createFactory(type) {\n  return createElement$2.bind(null, type);\n}\n\nvar WrapperComponent = function (Component$$1) {\n  function WrapperComponent() {\n    Component$$1.apply(this, arguments);\n  }\n\n  if (Component$$1) WrapperComponent.__proto__ = Component$$1;\n  WrapperComponent.prototype = Object.create(Component$$1 && Component$$1.prototype);\n  WrapperComponent.prototype.constructor = WrapperComponent;\n\n  WrapperComponent.prototype.getChildContext = function getChildContext$$1() {\n    // tslint:disable-next-line\n    return this.props.context;\n  };\n\n  WrapperComponent.prototype.render = function render$$1() {\n    return this.props.children;\n  };\n\n  return WrapperComponent;\n}(Component);\n\nfunction unstable_renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {\n  // @TODO: should handle props.context?\n  var wrapper = createElement$2(WrapperComponent, {\n    context: getChildContext(parentComponent, parentComponent.context)\n  }, vnode);\n  var rendered = render(wrapper, container);\n\n  if (callback) {\n    callback.call(rendered);\n  }\n\n  return rendered;\n}\n\nfunction isValidElement$1(element) {\n  return isValidElement(element) && (element.vtype & (4\n  /* Composite */\n  | 2\n  /* Node */\n  )) > 0;\n}\n\nvar unstable_batchedUpdates = nextTick;\nvar shim = noop$1;\nshim.isRequired = noop$1;\n\nfunction getShim() {\n  return shim;\n}\n\nvar PropTypes = {\n  array: shim,\n  bool: shim,\n  func: shim,\n  number: shim,\n  object: shim,\n  string: shim,\n  any: shim,\n  arrayOf: getShim,\n  element: shim,\n  instanceOf: getShim,\n  node: shim,\n  objectOf: getShim,\n  oneOf: getShim,\n  oneOfType: getShim,\n  shape: getShim,\n  exact: getShim,\n  PropTypes: {},\n  checkPropTypes: noop$1\n};\nPropTypes.PropTypes = PropTypes;\n\nfunction createRef() {\n  return {};\n}\n\nfunction forwardRef(cb) {\n  var fn = function (props) {\n    var ref = props.ref;\n    delete props.ref;\n    return cb(props, ref);\n  };\n\n  fn._forwarded = true;\n  return fn;\n}\n\nfunction memo(component, propsAreEqual) {\n  function shouldComponentUpdate(nextProps) {\n    var prevRef = this.props.ref;\n    var nextRef = nextProps.ref;\n\n    if (prevRef !== nextRef) {\n      Ref.detach(this.vnode, prevRef, this.dom);\n      Ref.attach(this.vnode, nextRef, this.dom);\n      return true;\n    }\n\n    return isFunction(propsAreEqual) ? !propsAreEqual(this.props, nextProps) : !shallowEqual(this.props, nextProps);\n  }\n\n  function Memoed(props) {\n    this.shouldComponentUpdate = shouldComponentUpdate;\n    return createElement$2(component, Object.assign({}, props));\n  }\n\n  Memoed._forwarded = true;\n  Memoed.isMemo = true;\n  return Memoed;\n}\n\nvar Emiter = function Emiter(value) {\n  this.handlers = [];\n  this.value = value;\n};\n\nEmiter.prototype.on = function on(handler) {\n  this.handlers.push(handler);\n};\n\nEmiter.prototype.off = function off(handler) {\n  this.handlers = this.handlers.filter(function (h) {\n    return h !== handler;\n  });\n};\n\nEmiter.prototype.set = function set(value) {\n  var this$1 = this;\n  this.value = value;\n  this.handlers.forEach(function (h) {\n    return h(this$1.value);\n  });\n};\n\nvar uid = 0;\n\nfunction onlyChild(children) {\n  return Array.isArray(children) ? children[0] : children;\n}\n\nfunction createContext(defaultValue) {\n  var contextProp = '__context_' + uid++ + '__';\n\n  var Provider = function (Component$$1) {\n    function Provider() {\n      Component$$1.apply(this, arguments);\n      this.emiter = new Emiter(this.props.value);\n    }\n\n    if (Component$$1) Provider.__proto__ = Component$$1;\n    Provider.prototype = Object.create(Component$$1 && Component$$1.prototype);\n    Provider.prototype.constructor = Provider;\n\n    Provider.prototype.getChildContext = function getChildContext() {\n      return obj = {}, obj[contextProp] = this.emiter, obj;\n      var obj;\n    };\n\n    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n      if (!objectIs(this.props.value, nextProps.value)) {\n        this.emiter.set(nextProps.value);\n      }\n    };\n\n    Provider.prototype.render = function render() {\n      return this.props.children;\n    };\n\n    return Provider;\n  }(Component);\n\n  Provider.isContextProvider = true; // tslint:disable-next-line: max-classes-per-file\n\n  var Consumer = function (Component$$1) {\n    function Consumer() {\n      var this$1 = this;\n      Component$$1.apply(this, arguments);\n      this.state = {\n        value: this.getContextValue()\n      };\n\n      this.onUpdate = function (value) {\n        if (!objectIs(value, this$1.state.value)) {\n          this$1.setState({\n            value: this$1.getContextValue()\n          });\n        }\n      };\n    }\n\n    if (Component$$1) Consumer.__proto__ = Component$$1;\n    Consumer.prototype = Object.create(Component$$1 && Component$$1.prototype);\n    Consumer.prototype.constructor = Consumer;\n\n    Consumer.prototype.componentWillMount = function componentWillMount() {\n      var emiter = this.context[contextProp];\n\n      if (emiter) {\n        emiter.off(this.onUpdate);\n      }\n    };\n\n    Consumer.prototype.componentDidMount = function componentDidMount() {\n      var emiter = this.context[contextProp];\n\n      if (emiter) {\n        emiter.on(this.onUpdate);\n      }\n    };\n\n    Consumer.prototype.getContextValue = function getContextValue() {\n      var emiter = this.context[contextProp];\n      return isUndefined(emiter) ? defaultValue : emiter.value;\n    };\n\n    Consumer.prototype.render = function render() {\n      return onlyChild(this.props.children)(this.state.value);\n    };\n\n    return Consumer;\n  }(Component);\n\n  Consumer.isContextConsumer = true;\n  return {\n    Provider: Provider,\n    Consumer: Consumer,\n    _id: contextProp,\n    _defaultValue: defaultValue\n  };\n}\n\nfunction Fragment(props) {\n  return props.children;\n} // tslint:disable-next-line: max-line-length\n\n\nvar index = {\n  Children: Children,\n  Component: Component,\n  PureComponent: PureComponent,\n  createElement: createElement$2,\n  cloneElement: cloneElement,\n  render: render,\n  nextTick: nextTick,\n  options: options,\n  findDOMNode: findDOMNode,\n  isValidElement: isValidElement$1,\n  unmountComponentAtNode: unmountComponentAtNode,\n  createPortal: createPortal,\n  unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,\n  hydrate: hydrate,\n  createFactory: createFactory,\n  unstable_batchedUpdates: unstable_batchedUpdates,\n  version: version,\n  PropTypes: PropTypes,\n  createRef: createRef,\n  forwardRef: forwardRef,\n  memo: memo,\n  createContext: createContext,\n  renderComponent: renderComponent,\n  getHooks: getHooks,\n  Current: Current,\n  useEffect: useEffect,\n  useLayoutEffect: useLayoutEffect,\n  useReducer: useReducer,\n  useState: useState,\n  useRef: useRef,\n  useCallback: useCallback,\n  useMemo: useMemo,\n  useImperativeHandle: useImperativeHandle,\n  useContext: useContext,\n  Fragment: Fragment\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n//# sourceURL=webpack:///./node_modules/nervjs/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./src/App.css":
/*!*********************!*\
  !*** ./src/App.css ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_App_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!../node_modules/postcss-loader/dist/cjs.js!./App.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/App.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_App_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_App_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});\n\n//# sourceURL=webpack:///./src/App.css?");

/***/ }),

/***/ "./src/App.jsx":
/*!*********************!*\
  !*** ./src/App.jsx ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nervjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nervjs */ \"./node_modules/nervjs/dist/index.esm.js\");\n/* harmony import */ var _App_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.css */ \"./src/App.css\");\nfunction _newArrowCheck(innerThis, boundThis) { if (innerThis !== boundThis) { throw new TypeError(\"Cannot instantiate an arrow function\"); } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\nfunction App(props) {\n  var _this = this;\n\n  var _useState = Object(nervjs__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var increment = Object(nervjs__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(function () {\n    _newArrowCheck(this, _this);\n\n    setValue(value + 1);\n  }.bind(this), [value]); // https://preactjs.com/guide/v10/hooks/#useeffect\n\n  var _useState3 = Object(nervjs__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(Date.now()),\n      _useState4 = _slicedToArray(_useState3, 2),\n      time = _useState4[0],\n      setTime = _useState4[1];\n\n  Object(nervjs__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    var _this2 = this;\n\n    _newArrowCheck(this, _this);\n\n    var timer = setInterval(function () {\n      _newArrowCheck(this, _this2);\n\n      setTime(Date.now());\n    }.bind(this), 1000);\n    return function cleanup() {\n      clearInterval(timer);\n    };\n  }.bind(this), []);\n  return /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"div\", null, /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"h1\", null, \"Hello \", this.props.name, \"!\"), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"h2\", null, \"\\u5F53\\u524D\\u65F6\\u95F4:\", /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"span\", null, new Date(time).toLocaleTimeString())), \"\\u5F53\\u524D\\u8BA1\\u6570: \", value, /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"button\", {\n    onClick: increment\n  }, \"\\u70B9\\u8FD9\\u91CC\\u589E\\u52A0\\u8BA1\\u6570\\uFF0C\\u4F53\\u9A8C React Hooks\"), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"button\", {\n    onClick: function () {\n      _newArrowCheck(this, _this);\n\n      external.hello(\"NervJS\", setValue);\n    }.bind(this)\n  }, \"\\u70B9\\u8FD9\\u91CC\\u76F4\\u63A5\\u8C03\\u7528 aardio \\u51FD\\u6570\\uFF0C\\u7136\\u540E\\u5728 aardio \\u91CC\\u56DE\\u8C03 React hook \\u51FD\\u6570\"), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), \"\\u4F7F\\u7528 NervJS  hooks \\u5C31\\u53EF\\u4EE5 \\u5728 web.form \\u91CC\\u4F7F\\u7528 React Hooks \\u5199\\u7F51\\u9875\\u4E86\\u3002\", /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), \"\\u53EF\\u652F\\u6301\\u81EA\\u5E26 IE9+ \\u4EE5\\u4E0A\\u7684\\u7CFB\\u7EDF\\uFF0C\\u81F3\\u4E8E IE8 \\u4F7F\\u7528\\u4EBA\\u6570\\u592A\\u5C11\\u4E0D\\u7528\\u518D\\u8003\\u8651\\u4E86\\u3002\", /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), \"React Hooks \\u7B80\\u6D01\\u4F18\\u96C5, \\u5927\\u5E45\\u964D\\u4F4E\\u4E86\\u524D\\u7AEF\\u5F00\\u53D1\\u7684\\u95E8\\u69DB\\u548C\\u5B66\\u4E60\\u6210\\u672C\\u3002\", /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), \"\\u53EA\\u8981\\u719F\\u6089 useState, useEffect, useCallback, useContext \\u7B49\\u51E0\\u4E2A\\u975E\\u5E38\\u7B80\\u5355\\u7684 Hooks \\u7684\\u7528\\u6CD5\\uFF0C\", /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), \"\\u4F60\\u5C31\\u53EF\\u4EE5\\u8FD0\\u7528\\u81EA\\u5982\\uFF0C\\u5F3A\\u70C8\\u63A8\\u8350\\u5927\\u5BB6\\u5B66\\u4E60\\u548C\\u4F7F\\u7528\\u3002\", /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null), /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(\"br\", null));\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (App);\n\n//# sourceURL=webpack:///./src/App.jsx?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var nervjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nervjs */ \"./node_modules/nervjs/dist/index.esm.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App */ \"./src/App.jsx\");\n\n\n\nnervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].render( /*#__PURE__*/nervjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createElement(_App__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n  name: \"NervJS\"\n}), document.getElementById('app'));\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });