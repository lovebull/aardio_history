import fsys.path;
import inet.installer;
import win.path;
import process;

namespace process.rust;

install = function(){
	var rustupPath = ..win.path.search("rustup.exe")
	var cargoPath = ..win.path.search("cargo.exe")
	if(!(rustupPath&&cargoPath)){
		if(!..inet.installer.asInvoker("Rust 语言编译器"
			,"https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe","-y")){
			return;
		}
		
		rustupPath = ..win.path.search("rustup.exe")
		cargoPath = ..win.path.search("cargo.exe")
	}
	
	return rustupPath,cargoPath; 
}

repair = function(){
	var prcs,err = ..process("cmd.exe","rustup uninstall stable && rustup update nightly && rustup update stable");
	if(!prcs){
		return null,err;
	}
	
	prcs.waitOne();
	var ret = prcs.getExitCode() == 0;
	prcs.free();
	
	return ret;	
}

workdir = ..io.fullpath("/");

rustup = function(cmdline){
	var rustupPath,cargoPath = install();
	if(!rustupPath) return;
		
	var prcs,err = ..process(  ,'rustup ' + cmdline,{ workdir = workdir; } ) 
	if(!prcs){
		return null,err;
	}
	
	prcs.waitOne();
	var ret = prcs.getExitCode() == 0;
	prcs.free();
	
	return ret;
}

cargo = function(cmdline,...){
	var rustupPath,cargoPath = install();
	if(!cargoPath) return;
	
	var prcs,err =  ..process(  ,'cargo ' + cmdline,{ workdir = workdir; } ) 
	if(!prcs){
		return null,err;
	}
	
	prcs.waitOne();
	var ret = prcs.getExitCode() == 0;
	prcs.free();
	
	return ret;
}

build = function(){
	if(!rustup("target add i686-pc-windows-msvc"))return;
	return cargo("build --target=i686-pc-windows-msvc --release");
}

createDllProject = function(fileName){ 
	fileName = ..fsys.path.validName(fileName);
	if(!#fileName){
		return null,"请指定合法的文件名"
	}
	
	var path = ..io.joinpath(workdir,fileName);
	
	if(..io.exist(path)){
		return null,"目录已存在"
	}
	
	var code = '
[package]\r\n
name = "'+fileName+'"\r\n
version = "0.1.0"\r\n
authors = ["aardio"]\r\n
\r\n
[lib]\r\n
name = "aardio_rust" \r\n
crate-type = ["cdylib"]\r\n
'
	..string.save(..io.joinpath(path,"Cargo.toml"),code)
	
	var code =/*
[build]
target = "i686-pc-windows-msvc"

[target.i686-pc-windows-msvc]
rustflags = ["-C","target-feature=+crt-static"]
#linker = "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Tools\\MSVC\\14.24.28314\\bin\\Hostx64\\x86\\link.exe"
*/
	..string.save(..io.joinpath(path,".cargo/config.toml"),code)

	var code =/*
use std::ffi::CStr;
use std::os::raw::c_char;

#[repr(C)]
pub struct CStruct{
    n: i32,
    f: f64, 
}

#[no_mangle]
pub extern fn hello_rust(ptr_utf8: *const c_char,info: &mut CStruct){
    let cstr = unsafe { CStr::from_ptr(ptr_utf8) };

    match cstr.to_str() {
        Ok(s) => {
			println!("{}",s);
        }
        Err(_) => {
          
        }
    }
    
    info.n = 123;
    info.f = 321.321;
}
*/
	..string.save(..io.joinpath(path,"src/lib.rs"),code)	
	
	workdir = path;
}

/**intellisense(process.rust)
workdir = 指定工作目录,默认为应用程序目录
install() = 如果没有安装 Rust 则自动安装 Rust
repair() = 修复安装
rustup(.(->->->) = 执行 rustup 命令,\n可输入一个或多个命令行参数,\n只有一个参数时直接作为命令行参数,\n多个参数则包含空格的参数置入引号内部并作必要的转义处理
cargo(.(->->->) = 执行 cargo 命令,\n可输入一个或多个命令行参数,\n只有一个参数时直接作为命令行参数,\n多个参数则包含空格的参数置入引号内部并作必要的转义处理
build(.() = 编译 32 位 DLL
createDllProject(.(path) = 创建32位DLL范例工程,\n输入目录必须是不存在的目录,\n创建成功自动设置该目录为 process.rust.workdir
end intellisense**/