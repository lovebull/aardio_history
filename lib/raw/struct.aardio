//struct 静态结构体
namespace raw

class struct {
	ctor( cls,ptr ) {{ 
		var tcls = type(cls);
		if(ptr){
			var tptr = type(ptr);
			if( tptr!==type.pointer && tptr!==type.buffer ){
				error("参数@2类型错误",2)
			} 
			
			if( tcls = "class"){
				this[["_structObject"]] = cls()
			}
			else {
				this[["_structObject"]] = ..table.assign({},cls);
			}
			
			this[["_arrayType"]] = ..string.match(this[["_structObject"]]._struct,"(\a+)\s+[^,\[]\[");
			if(this[["_arrayType"]]){
				this[["_arrayTypeSize"]] = ..raw.sizeof(this[["_arrayType"]]);
				this[["_arrayValue"]] = eval("{"+this[["_arrayType"]]+" v}")
			}
			
			this[["_structPointer"]] = ptr;
			this@ = _meta;
			return this;
		}
		
		var struct = class {
			ctor( ... ){
				if( tcls = "class"){
					this[["_structObject"]] = cls( ... )
				}
				else {
					this[["_structObject"]] = ..table.assign({},cls,...);
				}
				
				this[["_structPointer"]] = ..raw.buffer(this[["_structObject"]])
				
				this[["_arrayType"]] = ..string.match(this[["_structObject"]]._struct,"(\a+)\s+[^,\[]\[");
				if(this[["_arrayType"]]){
					this[["_arrayTypeSize"]] = ..raw.sizeof(this[["_arrayType"]]);
					this[["_arrayValue"]] = eval("{"+this[["_arrayType"]]+" v}")
				}
			};
			@_meta;
		}
		struct._meta =  _meta;
		return struct;
	}};  
}
	
namespace struct{
	var convert = ..raw.convert;
	var copy = ..raw.copy;
	
	_meta = {
		_topointer = function(){  
			return owner[["_structPointer"]]; 
		}
		_serialize = function(kernelCall){
			if(kernelCall) {
				return ..string.format("global.import('raw.struct') : raw.struct(%s,topointer(0x%p))"
					,..table.tostring(owner[["_structObject"]]),..raw.toPointer(owner[["_structPointer"]]));
			}
			else {
				return ..table.tostring(owner[["_structObject"]]);
			}
		}
		_get = function(k){ 
			var t = type(k);
			if( t === "number" ){
				if(owner[["_arrayType"]]){
					convert(owner[["_structPointer"]],owner[["_arrayValue"]],owner[["_arrayTypeSize"]]*(k-1));
					return owner[["_arrayValue"]].v;
				} 
				return;
			}
			else if(t!=="string") return;
			
			var struct = owner[["_structObject"]]; 
			convert(owner[["_structPointer"]],struct);
			
			if(type(struct["get_"+k])==="function"){
				return invoke(struct["get_"+k],struct);
			}
			else {
				return struct[k];
			}
		}
		_set = function( k, v ){ 
			var t = type(k);
			if( t === "number" ){ 
				if(owner[["_arrayType"]]){
					owner[["_arrayValue"]].v = v;
					convert(owner[["_arrayValue"]],owner[["_structPointer"]],owner[["_arrayTypeSize"]]*(k-1)); 
				} 
				return;
			}
			else if(t!=="string") return;
			
			if(type(v) === "function"){
				owner[[k]] = v;
				return;
			}
			
			var struct = owner[["_structObject"]]; 
			convert(owner[["_structPointer"]],struct); 
			
			if(type(struct["set_"+k])==="function"){
				invoke(struct["set_"+k],struct,v);
			}
			else {
				struct[k] = v;	
			}
			
			copy(owner[["_structPointer"]],struct); 
		} 
	} 
} 

/**intellisense()
raw.struct = 创建静态结构体,\naardio 默认使用动态内存结构体在与静态接口交互时动态分配内存指针,\n但静态结构体可以分配固定不变的内存指针\n\n读写静态结构体字段时直接自内存读写\n如果结构体首个成员为静态类型数组,可直接用数值索引读写该数组成员
raw.struct = 创建静态结构体\n静态结构体可直接传入其他线程,\n多线程可直接共享同一静态结构体内存指针,\n但必须由创建静态结构体的线程负责维护该结构体的有效生命周期\n
raw.struct(.(结构体类) = 创建返回静态结构体的类对象,\n创建静态结构体时自动分配内存缓冲区并绑定该指针,\n参数可以是定义了静态类型的结构体基类，也可以是结构体原型对象,\n如果参数是原型结构体,返回类的构造函数默认混入参数和原型并返回新的结构体,\n结构体可使用get_,set_前缀的函数名自定义属性读写器
raw.struct(.(结构体类,内存指针) = 创建返回静态结构体实例,并绑定参数@2指定的内存指针,\n参数@1可以是定义了静态类型的结构体基类，也可以是结构体原型对象,\n结构体可使用get_,set_前缀的函数名自定义属性读写器
end intellisense**/